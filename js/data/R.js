// Generated by CoffeeScript 1.11.1
var ID_RandomDice, ID_RecursiveCircle, ID_RedCone, ID_RedRect, ID_Reversi, ID_RotatedEllipse, ID_RotatedRectA, ID_RotatedRectB, ID_RotatedRectC, ID_Roulette, ID_RubikCube, ID_RubikSquare, ID_RushHour;

ID_RandomDice = {
  v: '2017-04-29',
  b: "# LOC:19 bg fc sc circle # % %% / * + << & [] int Math.sin\n#        for in class extends constructor new @ super ->\n\nclass RandomDice extends Application\n	reset : ->\n		super\n		@seed = 0\n	draw : ->\n	mousePressed : (mx,my) ->\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\napp = new RandomDice",
  a: "class RandomDice extends Application\n	reset : ->\n		super\n		@RADIUS = 20\n		@BITS = [0,1,24,25,90,91,126]\n		@XY = [22,11,12,13,31,32,33]\n		@seed = 0\n		@throw()\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\n	throw : -> @value = 1 + @randint 6\n	mousePressed : (mx,my) -> @throw()\n	draw : ->\n		bg 1\n		sc 1\n		for xy,i in @XY\n			x = int xy/10\n			y = xy % 10\n			if @BITS[@value] & 1<<i then circle 50*x,50*y,@RADIUS\n\napp = new RandomDice \"a\"",
  c: {
    app: "reset()"
  }
};

ID_RecursiveCircle = {
  v: '2017-04-29',
  b: "# LOC:10 sc circle # if return < class extends constructor new @ super ->\n\nclass RecursiveCircle extends Application\n	reset   : ->\n		super\n	draw    : ->\n	circles : (x,y,r,level) ->\n	mousePressed : (mx,my) ->\napp = new RecursiveCircle",
  a: "\nclass RecursiveCircle extends Application\n	reset : ->\n		super\n		@n = 0\n	draw : -> @circles 100,100,100,@n\n	circles : (x,y,r,level) ->\n		circle x,y,r\n		if level <= 0 then return\n		@circles x-r/2, y, r/2, level-1\n		@circles x+r/2, y, r/2, level-1\n	mousePressed : (mx,my) -> @n = constrain @n + (if my < 100 then 1 else -1),0,10\n\napp = new RecursiveCircle \"a\"",
  c: {
    app: "reset()"
  }
};

ID_RedCone = {
  v: '2017-04-29',
  b: "# LOC:6 range fc circle # for in lerp\n",
  a: "for i in range 10,0,-1\n	fc i/10.0,0,0\n	x = 10*i\n	y = 10*i\n	r = 10*i\n	circle x,y,r"
};

ID_RedRect = {
  v: '2017-04-29',
  b: "# LOC:2 fc # rect\n",
  a: "fc 1,0,0\nrect 80,70, 40,100"
};

ID_Reversi = {
  v: '2017-05-02',
  b: "# LOC:49 sc fc bg range # [] push length rect circle not and while if then\n#        % + - * / <= < == class extends constructor new @ super ->\n\nclass Reversi extends Application\n	reset : ->\n		super\n	draw : ->\n	mousePressed : (mx,my) ->\napp = new Reversi",
  a: "class Reversi extends Application\n	reset : ->\n		super\n		@newGame()\n	newGame : ->\n		@board = []\n		@drag = 0\n		for j in range 8\n			@board.push []\n			for i in range 8\n				@board[j].push 0\n		@board[3][3]=2 # White\n		@board[3][4]=1 # Black\n		@board[4][3]=1\n		@board[4][4]=2\n	draw : ->\n		sc 0\n		for i in range 8\n			for j in range 8\n				sq = @board[j][i]\n				fc 0,1,0\n				rect 20+20*i, 20+20*j,20,20\n				if sq in [1,2]\n					fc sq-1\n					circle 30.5+20*i, 30.5+20*j,10-2\n	move : (i,j) ->\n		res = []\n		mycol = 1 + @drag % 2\n		other = [0,2,1][mycol]\n		for di in [-1,0,1]\n			for dj in [-1,0,1]\n				if not (di==0 and dj==0)\n					i1=i+di\n					j1=j+dj\n					temp = []\n					while 0 <= i1 < 8 and 0 <= j1 < 8 and @board[j1][i1] == other\n						temp.push [i1,j1]\n						i1 = i1+di\n						j1 = j1+dj\n					if 0 <= i1 < 8 and 0 <= j1 < 8 and @board[j1][i1] == mycol\n						if temp.length > 0 then	res = res.concat temp\n		if res.length > 0\n			@board[j][i] = mycol\n			for [i,j] in res then	@board[j][i] = mycol\n			@drag++\n	mousePressed : (mx,my) ->\n		i = int mx / 20 - 1\n		j = int my / 20 - 1\n		if 0 <= i < 8 and 0 <= j < 8 and @board[j][i] == 0 then @move i,j\n\napp = new Reversi \"a\"",
  c: {
    app: "reset()"
  },
  e: {
    Reversi: "https://en.wikipedia.org/wiki/Reversi"
  }
};

ID_RotatedEllipse = {
  v: '2017-04-29',
  b: "# LOC:5 rd # ellipse translate\n",
  a: "fc 1,0,0\nsc()\ntranslate 100,100\nrd 45\nellipse 0,0, 80,40"
};

ID_RotatedRectA = {
  v: '2017-04-29',
  b: "# LOC:4 fc # rect\n",
  a: "fc 1,0,0\nrect 60,100, 40,40\nfc 0,1,0\nrect 140,100, 40,40"
};

ID_RotatedRectB = {
  v: '2017-04-29',
  b: "# LOC:12 fc rd # rect translate push pop\n",
  a: "push()\nfc 1,0,0\ntranslate 60,100\nrd 45\nrect 0,0, 40,40\npop()\npush()\nfc 0,1,0\ntranslate 140,100\nrd 45\nrect 0,0, 40,40\npop()"
};

ID_RotatedRectC = {
  v: '2017-04-29',
  b: "# LOC:13 fc rd # rect translate push pop\n",
  a: "rectMode CENTER\npush()\nfc 1,0,0\ntranslate 80,120\nrd 45\nrect 0,0, 40,40\npop()\npush()\nfc 0,1,0\ntranslate 160,120\nrd 45\nrect 0,0, 40,40\npop()"
};

ID_Roulette = {
  v: '2017-04-29',
  b: "# LOC:15 bg sw fc sc range rd # for in if then else == % / [] \"\" PI\n#        length text textAlign arc strokeCap translate push pop\n\nnumbers = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26]",
  a: "numbers = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26]\nbg 0.5\ntranslate 100,100\nd = PI/numbers.length\nsw 20\nstrokeCap SQUARE\ntextAlign CENTER,CENTER\nfor number,i in numbers\n	fc()\n	if i==0 then sc 0,1,0 else sc i%2,0,0\n	arc 0,0,180,180,-PI/2-d,-PI/2+d\n	sc()\n	fc 1\n	text number,0,-90\n	rd 360 / numbers.length",
  e: {
    Wikipedia: "https://en.wikipedia.org/wiki/Roulette"
  }
};

ID_RubikCube = {
  v: '2017-04-29',
  b: "# LOC:121 bg fc sc range # [] push pop concat length if then else constrain for in int quad\n#         text textSize textAlign dist + - * / class extends constructor new @ super ->\n\nclass RubikCube extends Application\n	reset : ->\n		super\n	draw : ->\n	mousePressed : (mx,my) ->\n	toggleNumbers : ->\napp = new RubikCube",
  a: "class RubikCube extends Application\n	newGame : ->\n		@level = @level + if @level==@history.length then 1 else -1\n		@level = constrain @level,0,100\n		@history = []\n		@board = []\n		@memory = -1\n		@board.push i for i in range 54\n		for i in range @level\n			@op @randint(6), 2*@randint(2)-1\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\n	undo : ->\n		if @history.length==0 then return\n		@memory = -1\n		[k,d] = @history.pop()\n		@op k,-d\n	turn : (a,b) -> # a,b in 0..54\n		if int(a/9) != int(b/9) then return\n		d = (a%9 - b%9)/2\n		if d in [-3,3] then d = -d/3\n		if d not in [-1,1] then return\n		k = int a/9\n		@op k,d\n		@history.push [k,d]\n	op : (k,d) -> # 0..5, [-1,1]\n		tiles = [\n			[0,1,42,41,40,   2,3,9,16,15,    4,5,20,19,18,   6,7,31,30,29]\n			[9,10,40,39,38,  11,12,49,48,47, 13,14,22,21,20, 15,16,4,3,2]\n			[18,19,6,5,4,    20,21,15,14,13, 22,23,47,46,45, 24,25,33,32,31]\n			[27,28,36,43,42, 29,30,0,7,6,    31,32,18,25,24, 33,34,45,52,51]\n			[36,37,51,50,49, 38,39,11,10,9,  40,41,2,1,0,    42,43,29,28,27]\n			[45,46,24,23,22, 47,48,13,12,11, 49,50,38,37,36, 51,52,27,34,33]]\n		arr = tiles[k]\n		carr = (@board[i] for i in arr)\n		limit = if d==1 then 5 else 15\n		carr = carr[limit..20].concat carr[0..limit]\n		@board[arr[i]] = carr[i] for i in range 20\n	reset : ->\n		super\n		@board = []\n		@memory = -1\n		@level = -1\n		@history = []\n		@buttons = [[40,140,@level], [160,140,\"new\"]]\n		@showNumbers = false\n		@seed = 0\n		@newGame()\n	colorize : (index,board) ->\n		k = int board[index] / 9\n		[r,g,b] = [[1,1,1],[0,0,1],[1,0,0],[0,1,0],[0.97, 0.57, 0],[1,1,0]][k]\n		fc r,g,b\n	textColorize : (index,board) -> fc [0,1,1,0,0,0][int board[index] / 9]\n	rita : (x,y,index,tilt,self) ->\n		a = 16\n		b = 9\n		self.colorize index,self.board\n		sc 0\n		if tilt == 0 then quad x-a,y, x,y-b, x+a,y, x,y+b\n		if tilt == 1 then quad x+a/2,y-b/2, x-a/2,y-3*b/2, x-a/2,y+b/2, x+a/2,y+3*b/2\n		if tilt == 2 then quad x-a/2,y-b/2, x+a/2,y-3*b/2, x+a/2,y+b/2, x-a/2,y+3*b/2\n		self.textColorize index,self.board\n		sc()\n		if self.showNumbers then text self.board[index],x,y\n		if self.memory? and index == self.memory then circle x,y,4\n		false\n	sense : (x,y,index,tilt,self) -> dist(x,y,mouseX,mouseY) < 9\n	draw : ->\n		bg 0\n		textSize 12\n		textAlign CENTER,CENTER\n		@traverse @rita\n		fc 1,1,0\n		textSize 20\n		@buttons[0][2] = @level - @history.length\n		text txt,x,y for [x,y,txt] in @buttons\n	traverse : (f) ->\n		a = 16\n		b = 9\n		y0 = 60\n		for index in range 54\n			side = int index / 9\n			if side==0 # vit\n				i = [-1,-1,-1,0,1,1,1,0,0][index % 9]\n				j = [0,1,2,2,2,1,0,0,1][index % 9]\n				if f 100+a*(i+j-1),y0+b*(i-j+1), index, 0,@ then return index\n			if side==1 # blå\n				i = [-1,-1,-1,0,1,1,1,0,0][index % 9]\n				j = [0,1,2,2,2,1,0,0,1][index % 9]\n				if f 100+a*(i+4.5),y0+b*(2*j+i-3.5), index, 1,@ then return index\n			if side==2 # röd\n				i = [-1,0,1,1,1,0,-1,-1,0][index % 9]\n				j = [0,0,0,1,2,2,2,1,1][index % 9]\n				if f 100+a*(i+1.5),y0+b*(2*j-i+2.5), index, 2,@ then return index\n			if side==3 # grön\n				i = [-1,-1,-1,0,1,1,1,0,0][index % 9]\n				j = [2,1,0,0,0,1,2,2,1][index % 9]\n				if f 100+a*(i-1.5),y0+b*(2*j+i+2.5), index, 1,@ then return index\n			if side==4 # orange\n				i = [-1, 0, 1, 1, 1, 0,-1,-1, 0][index % 9]\n				j = [ 2, 2, 2, 1, 0, 0, 0, 1, 1][index % 9]\n				if f 100+a*(i-4.5),y0+b*(2*j-i-3.5), index, 2,@ then return index\n			if side==5 # gul\n				i = [ 1, 1, 1, 0,-1,-1,-1, 0, 0][index % 9]\n				j = [ 0, 1, 2, 2, 2, 1, 0, 0, 1][index % 9]\n				if f 100+a*(i+j-1),y0+b*(i-j+13), index, 0,@ then return index\n		-1\n	mousePressed : (mx,my) ->\n		for [x,y,txt],i in @buttons\n			if dist(mx,my,x,y) < 10\n				if i==0 then return @undo()\n				if i==1 then return @newGame()\n		if @memory == -1\n			@memory = @traverse @sense\n			if @memory != -1\n				if @memory%9==8 then @memory = -1\n		else\n			index = @traverse @sense\n			if index != -1 and index%9 != 8 then @turn @memory,index\n			@memory = -1\n	toggleNumbers : ->\n		@showNumbers = not @showNumbers\n\napp = new RubikCube \"a\"\n\n",
  c: {
    app: "reset()|toggleNumbers()"
  },
  e: {
    "RubikCube": "https://sv.wikipedia.org/wiki/Rubiks_kub"
  }
};

ID_RubikSquare = {
  v: '2017-04-29',
  b: "# LOC:85 bg fc sc circle # [] push length int .. + - * / % %% == < & << if then else rectMode rect push pop not \"\" split join\n#        parseInt _.isEqual text textAlign textSize rectMode while and constrain class extends constructor new @ super ->\n# OBS: Du bör använda variabeln rubikSquareData.\n\nclass RubikSquare extends Application\n	reset : ->\n	draw : ->\n	mousePressed : (mx,my) ->\napp = new RubikSquare",
  a: "class RubikSquare extends Application\n	reset : ->\n		super\n		@BUTTONS = [[4,3,3,3],[10,3,3,3],[16,3,3,3], [4,9,3,3],[10,9,3,3],[16,9,3,3], [4,15,3,3],[10,15,3,3],[16,15,3,3], [4,19,3,1],[10,19,3,1],[16,19,3,1]]\n		@seed = 0\n		@level = 1\n		@history = []\n		@memory = -1\n		@createGame()\n\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\n\n	newGame : ->\n		if @level >= @history.length and _.isEqual @board,[0,1,2,0,1,2,0,1,2] then d=1 else d=-1\n		@level = constrain @level+d,1,6\n		@history = []\n		@createGame()\n\n	createGame : ->\n		bigstring = rubikSquareData[@level]\n		arr = bigstring.split ' '\n		s = arr[@randint(arr.length)]\n		@board = (parseInt(ch) for ch in s)\n\n	move : (m,d,board) ->\n		[i,j,k] = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8]][m]\n		bd = board[..]\n		[a,b,c] = [bd[i],bd[j],bd[k]]\n		if d==0 then [a,b,c] = [b,c,a] else [a,b,c] = [c,a,b]\n		[bd[i],bd[j],bd[k]] = [a,b,c]\n		bd\n\n	draw : ->\n		bg 0\n		textAlign CENTER,CENTER\n		textSize 20\n		rectMode CENTER,CENTER\n		for c,i in @board\n			sc 1\n			if c==0 then fc 1,0,0\n			if c==1 then fc 0,1,0\n			if c==2 then fc 0,0,1\n			[x,y,w,h] = @BUTTONS[i]\n			rect 10*x,10*y,20*w,20*h\n		if @memory >= 0\n			[x,y,w,h] = @BUTTONS[@memory]\n			fc 0\n			sc()\n			circle 10*x,10*y,10\n		[x,y,w,h] = @BUTTONS[10]\n		fc 1,1,0\n		sc()\n		text @level-@history.length,10*x,10*y\n		if @history.length > 0\n			[x,y,w,h] = @BUTTONS[9]\n			text \"undo\",10*x,10*y\n			[x,y,w,h] = @BUTTONS[11]\n			text \"new\",10*x,10*y\n\n	undo : ->\n		if @history.length == 0 then return\n		@board = @history.pop()\n		@memory = -1\n\n	mousePressed : (mx,my) ->\n		index = -1\n		for [x,y,w,h],i in @BUTTONS\n			if x-w <= mx/10 <= x+w and y-h <= my/10 <= y+h then index = i\n		if 0 <= index < 9\n			if @memory == -1\n				@memory = index\n			else if @memory == index\n				@memory = -1\n			else\n				hash =\n					\"01\":[0,1], \"02\":[0,0], \"10\":[0,0], \"12\":[0,1], \"20\":[0,1], \"21\":[0,0]\n					\"34\":[1,1], \"35\":[1,0], \"43\":[1,0], \"45\":[1,1], \"53\":[1,1], \"54\":[1,0]\n					\"67\":[2,1], \"68\":[2,0], \"76\":[2,0], \"78\":[2,1], \"86\":[2,1], \"87\":[2,0]\n					\"03\":[3,1], \"06\":[3,0], \"30\":[3,0], \"36\":[3,1], \"60\":[3,1], \"63\":[3,0]\n					\"14\":[4,1], \"17\":[4,0], \"41\":[4,0], \"47\":[4,1], \"71\":[4,1], \"74\":[4,0]\n					\"25\":[5,1], \"28\":[5,0], \"52\":[5,0], \"58\":[5,1], \"82\":[5,1], \"85\":[5,0]\n				pair = hash[\"\" + @memory + index]\n				if pair\n					[m,d] = pair\n					@history.push @board[..]\n					@board = @move m,d,@board\n					@memory = -1\n		if index==9 then @undo()\n		if index==11 then @newGame()\n\napp = new RubikSquare \"a\"\n",
  c: {
    app: "reset()"
  }
};

ID_RushHour = {
  v: '2017-04-29',
  b: "# LOC:71 bg sc fc range # / % + * - == >= ++ -- \"\" [] {} push class extends constructor new @ super ->\n#        rect text textAlign for in if then else toLowerCase indexOf _.create prototype length @readText\n\n# De 36 rutorna numreras:\n#   0 1 2 3 4 5\n#   6 7 8 9 a b\n#   c d e f g h\n#   i j k l m n\n#   o p q r s t\n#   u v w x y z\n#\n# Placering av fordon:\n#   horisontellt: A=2 B=3\n#   vertikalt:    C=2 D=3\n#\n# Lösningar:\n# 	Bilarna namnges i följden XABCDEFGHIJKLMNOPQR\n# 	liten bokstav: vänster/uppåt\n# 	stor bokstav:  höger/nedåt\n\nclass Car\n	constructor : (ch,wh,@c) ->\n	render      : ->\n	move        : (d) ->\n\nclass RushHour extends Application\n	classes    : -> [Car]\n	reset      : ->\n		super\n	draw       : ->\n	enter_cars : -> # Ad0sBwCoD569\n	enter_move : -> # bbbEEEAfdccGGXXXXX\n	begin      : ->\n	backward   : (n=1) ->\n	forward    : (n=1) ->\n	end        : ->\napp = new RushHour\n",
  a: "class Car\n	constructor : (ch,wh,@c) ->\n		index = \"0123456789abcdefghijklmnopqrstuvwxyz\".indexOf ch\n		@i = index % 6\n		@j = int index / 6\n		[@w,@h] = wh\n\n	render : ->\n		fcc (@c+1) % 8\n		rect 40+20*@i+2, 40+20*@j+2, 20*@w-4, 20*@h-4\n		fc 0\n		tcc (@c+1) % 8\n		name = \"XABCDEFGHIJKLMNOP\"[@c]\n		small = name.toLowerCase()\n		text small, 50+20*@i,        50+20*@j\n		text name,  50+20*(@i+@w-1), 50+20*(@j+@h-1)\n\n	move : (d) -> # -1 eller +1\n		if @w == 1 then @j += d\n		if @h == 1 then @i += d\n\nclass RushHour extends Application\n	classes : -> [Car]\n	reset : ->\n		super\n		@enter_cars1 \"Ad0sBwCoD569\"\n		@enter_move1 \"bbbEEEAfdccGGXXXXX\"\n		@begin()\n\n	draw : ->\n		textAlign CENTER,CENTER\n		bg 0\n		sc()\n		fc 0.5\n		rect 40,40,120,120\n		rect 160,80,40,20\n		fc 1\n		sc()\n		for i in range 6\n			text \"012345\"[i],30,50+20*i\n			text \"012345\"[i],50+20*i,170\n		for car in @cars\n			car.render()\n\n	enter_cars : -> @enter_cars1 @readText()\n	enter_cars1 : (s) ->\n		@cars = []\n		@moves = \"\"\n		@index = 0\n		for ch in s\n			if ch in \"ABCD\" then wh = {A:[2,1], B:[3,1], C:[1,2], D:[1,3]}[ch]\n			else @cars.push new Car ch,wh,@cars.length\n\n	enter_move : -> @enter_move1 @readText()\n	enter_move1 : (s) ->\n		@moves = @moves[...@index]\n		@moves += s\n		@forward s.length\n\n	begin : -> @backward @index\n	backward : (n=1) ->\n		for i in range n\n			if @index == 0 then return\n			@index--\n			@bothward \"XABCDEFGHIJKLMNO\",\"xabcdefghijklmno\"\n	forward : (n=1) ->\n		for i in range n\n			if @index >= @moves.length then return\n			@bothward \"xabcdefghijklmno\",\"XABCDEFGHIJKLMNO\"\n			@index++\n	end : -> @forward @moves.length - @index\n\n	bothward : (a,b) ->\n		i = a.indexOf @moves[@index]\n		j = b.indexOf @moves[@index]\n		if i >= 0 then @cars[i].move -1\n		if j >= 0 then @cars[j].move +1\n\napp = new RushHour \"a\"",
  c: {
    app: "reset()|enter_cars()|enter_move()|begin()|backward()|forward()|end()"
  },
  e: {
    RushHour: "https://en.wikipedia.org/wiki/Rush_Hour_(board_game)"
  }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUi5qcyIsInNvdXJjZVJvb3QiOiIuLlxcLi4iLCJzb3VyY2VzIjpbImNvZmZlZVxcZGF0YVxcUi5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLElBQUE7O0FBQUEsYUFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUcsNFRBREg7RUFjQSxDQUFBLEVBQUUsc2RBZEY7RUFvQ0EsQ0FBQSxFQUNDO0lBQUEsR0FBQSxFQUFNLFNBQU47R0FyQ0Q7OztBQXVDRCxrQkFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUcsbVBBREg7RUFZQSxDQUFBLEVBQUcsc1hBWkg7RUE0QkEsQ0FBQSxFQUNDO0lBQUEsR0FBQSxFQUFNLFNBQU47R0E3QkQ7OztBQStCRCxVQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSx5Q0FERjtFQUVBLENBQUEsRUFBRSx3RkFGRjs7O0FBV0QsVUFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUUscUJBREY7RUFFQSxDQUFBLEVBQUUsOEJBRkY7OztBQU9ELFVBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFHLHVRQURIO0VBWUEsQ0FBQSxFQUFHLDByQ0FaSDtFQWlFQSxDQUFBLEVBQ0M7SUFBQSxHQUFBLEVBQU0sU0FBTjtHQWxFRDtFQW1FQSxDQUFBLEVBQ0M7SUFBQSxPQUFBLEVBQVUsdUNBQVY7R0FwRUQ7OztBQXNFRCxpQkFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUUsa0NBREY7RUFFQSxDQUFBLEVBQUUsOERBRkY7OztBQVVELGVBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFFLHFCQURGO0VBRUEsQ0FBQSxFQUFFLDZEQUZGOzs7QUFTRCxlQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSw0Q0FERjtFQUVBLENBQUEsRUFBRSx1SUFGRjs7O0FBaUJELGVBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFFLDRDQURGO0VBRUEsQ0FBQSxFQUFFLHdKQUZGOzs7QUFrQkQsV0FBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUUsNFBBREY7RUFPQSxDQUFBLEVBQUUsNFhBUEY7RUF3QkEsQ0FBQSxFQUNDO0lBQUEsU0FBQSxFQUFZLHdDQUFaO0dBekJEOzs7QUEyQkQsWUFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUUscVVBREY7RUFhQSxDQUFBLEVBQUUsb2dJQWJGO0VBNElBLENBQUEsRUFDQztJQUFBLEdBQUEsRUFBTSx5QkFBTjtHQTdJRDtFQThJQSxDQUFBLEVBQ0M7SUFBQSxXQUFBLEVBQWMsMENBQWQ7R0EvSUQ7OztBQWlKRCxjQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSxtYUFERjtFQVlBLENBQUEsRUFBRSxrbUZBWkY7RUEwR0EsQ0FBQSxFQUNDO0lBQUEsR0FBQSxFQUFNLFNBQU47R0EzR0Q7OztBQTZHRCxXQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSw2NUJBREY7RUF5Q0EsQ0FBQSxFQUFFLHkwREF6Q0Y7RUEwSEEsQ0FBQSxFQUNDO0lBQUEsR0FBQSxFQUFNLHNFQUFOO0dBM0hEO0VBNEhBLENBQUEsRUFDQztJQUFBLFFBQUEsRUFBVyxzREFBWDtHQTdIRCIsInNvdXJjZXNDb250ZW50IjpbIklEX1JhbmRvbURpY2UgPVxuXHR2OicyMDE3LTA0LTI5J1xuXHRiOiBcIlwiXCJcbiMgTE9DOjE5IGJnIGZjIHNjIGNpcmNsZSAjICUgJSUgLyAqICsgPDwgJiBbXSBpbnQgTWF0aC5zaW5cbiMgICAgICAgIGZvciBpbiBjbGFzcyBleHRlbmRzIGNvbnN0cnVjdG9yIG5ldyBAIHN1cGVyIC0+XG5cbmNsYXNzIFJhbmRvbURpY2UgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0XHRAc2VlZCA9IDBcblx0ZHJhdyA6IC0+XG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT5cblx0cmFuZGludCA6IChuKSAtPiBpbnQgbiAqIGZyYWN0aW9uIDEwMDAwICogTWF0aC5zaW4gQHNlZWQrK1xuYXBwID0gbmV3IFJhbmRvbURpY2VcblwiXCJcIlxuXHRhOlwiXCJcIlxuY2xhc3MgUmFuZG9tRGljZSBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRcdEBSQURJVVMgPSAyMFxuXHRcdEBCSVRTID0gWzAsMSwyNCwyNSw5MCw5MSwxMjZdXG5cdFx0QFhZID0gWzIyLDExLDEyLDEzLDMxLDMyLDMzXVxuXHRcdEBzZWVkID0gMFxuXHRcdEB0aHJvdygpXG5cdHJhbmRpbnQgOiAobikgLT4gaW50IG4gKiBmcmFjdGlvbiAxMDAwMCAqIE1hdGguc2luIEBzZWVkKytcblx0dGhyb3cgOiAtPiBAdmFsdWUgPSAxICsgQHJhbmRpbnQgNlxuXHRtb3VzZVByZXNzZWQgOiAobXgsbXkpIC0+IEB0aHJvdygpXG5cdGRyYXcgOiAtPlxuXHRcdGJnIDFcblx0XHRzYyAxXG5cdFx0Zm9yIHh5LGkgaW4gQFhZXG5cdFx0XHR4ID0gaW50IHh5LzEwXG5cdFx0XHR5ID0geHkgJSAxMFxuXHRcdFx0aWYgQEJJVFNbQHZhbHVlXSAmIDE8PGkgdGhlbiBjaXJjbGUgNTAqeCw1MCp5LEBSQURJVVNcblxuYXBwID0gbmV3IFJhbmRvbURpY2UgXCJhXCJcblwiXCJcIlxuXHRjOlxuXHRcdGFwcCA6IFwicmVzZXQoKVwiXG5cbklEX1JlY3Vyc2l2ZUNpcmNsZSA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6IFwiXCJcIlxuIyBMT0M6MTAgc2MgY2lyY2xlICMgaWYgcmV0dXJuIDwgY2xhc3MgZXh0ZW5kcyBjb25zdHJ1Y3RvciBuZXcgQCBzdXBlciAtPlxuXG5jbGFzcyBSZWN1cnNpdmVDaXJjbGUgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCAgIDogLT5cblx0XHRzdXBlclxuXHRkcmF3ICAgIDogLT5cblx0Y2lyY2xlcyA6ICh4LHkscixsZXZlbCkgLT5cblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuYXBwID0gbmV3IFJlY3Vyc2l2ZUNpcmNsZVxuXCJcIlwiXG5cdGE6IFwiXCJcIlxuXG5jbGFzcyBSZWN1cnNpdmVDaXJjbGUgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0XHRAbiA9IDBcblx0ZHJhdyA6IC0+IEBjaXJjbGVzIDEwMCwxMDAsMTAwLEBuXG5cdGNpcmNsZXMgOiAoeCx5LHIsbGV2ZWwpIC0+XG5cdFx0Y2lyY2xlIHgseSxyXG5cdFx0aWYgbGV2ZWwgPD0gMCB0aGVuIHJldHVyblxuXHRcdEBjaXJjbGVzIHgtci8yLCB5LCByLzIsIGxldmVsLTFcblx0XHRAY2lyY2xlcyB4K3IvMiwgeSwgci8yLCBsZXZlbC0xXG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT4gQG4gPSBjb25zdHJhaW4gQG4gKyAoaWYgbXkgPCAxMDAgdGhlbiAxIGVsc2UgLTEpLDAsMTBcblxuYXBwID0gbmV3IFJlY3Vyc2l2ZUNpcmNsZSBcImFcIlxuXCJcIlwiXG5cdGM6XG5cdFx0YXBwIDogXCJyZXNldCgpXCJcblxuSURfUmVkQ29uZSA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCIjIExPQzo2IHJhbmdlIGZjIGNpcmNsZSAjIGZvciBpbiBsZXJwXFxuXCJcblx0YTpcIlwiXCJcbmZvciBpIGluIHJhbmdlIDEwLDAsLTFcblx0ZmMgaS8xMC4wLDAsMFxuXHR4ID0gMTAqaVxuXHR5ID0gMTAqaVxuXHRyID0gMTAqaVxuXHRjaXJjbGUgeCx5LHJcblwiXCJcIlxuXG5JRF9SZWRSZWN0ID1cblx0djonMjAxNy0wNC0yOSdcblx0YjpcIiMgTE9DOjIgZmMgIyByZWN0XFxuXCJcblx0YTpcIlwiXCJcbmZjIDEsMCwwXG5yZWN0IDgwLDcwLCA0MCwxMDBcblwiXCJcIlxuXG5JRF9SZXZlcnNpID1cblx0djonMjAxNy0wNS0wMidcblx0YjogXCJcIlwiXG4jIExPQzo0OSBzYyBmYyBiZyByYW5nZSAjIFtdIHB1c2ggbGVuZ3RoIHJlY3QgY2lyY2xlIG5vdCBhbmQgd2hpbGUgaWYgdGhlblxuIyAgICAgICAgJSArIC0gKiAvIDw9IDwgPT0gY2xhc3MgZXh0ZW5kcyBjb25zdHJ1Y3RvciBuZXcgQCBzdXBlciAtPlxuXG5jbGFzcyBSZXZlcnNpIGV4dGVuZHMgQXBwbGljYXRpb25cblx0cmVzZXQgOiAtPlxuXHRcdHN1cGVyXG5cdGRyYXcgOiAtPlxuXHRtb3VzZVByZXNzZWQgOiAobXgsbXkpIC0+XG5hcHAgPSBuZXcgUmV2ZXJzaVxuXCJcIlwiXG5cdGE6IFwiXCJcIlxuY2xhc3MgUmV2ZXJzaSBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRcdEBuZXdHYW1lKClcblx0bmV3R2FtZSA6IC0+XG5cdFx0QGJvYXJkID0gW11cblx0XHRAZHJhZyA9IDBcblx0XHRmb3IgaiBpbiByYW5nZSA4XG5cdFx0XHRAYm9hcmQucHVzaCBbXVxuXHRcdFx0Zm9yIGkgaW4gcmFuZ2UgOFxuXHRcdFx0XHRAYm9hcmRbal0ucHVzaCAwXG5cdFx0QGJvYXJkWzNdWzNdPTIgIyBXaGl0ZVxuXHRcdEBib2FyZFszXVs0XT0xICMgQmxhY2tcblx0XHRAYm9hcmRbNF1bM109MVxuXHRcdEBib2FyZFs0XVs0XT0yXG5cdGRyYXcgOiAtPlxuXHRcdHNjIDBcblx0XHRmb3IgaSBpbiByYW5nZSA4XG5cdFx0XHRmb3IgaiBpbiByYW5nZSA4XG5cdFx0XHRcdHNxID0gQGJvYXJkW2pdW2ldXG5cdFx0XHRcdGZjIDAsMSwwXG5cdFx0XHRcdHJlY3QgMjArMjAqaSwgMjArMjAqaiwyMCwyMFxuXHRcdFx0XHRpZiBzcSBpbiBbMSwyXVxuXHRcdFx0XHRcdGZjIHNxLTFcblx0XHRcdFx0XHRjaXJjbGUgMzAuNSsyMCppLCAzMC41KzIwKmosMTAtMlxuXHRtb3ZlIDogKGksaikgLT5cblx0XHRyZXMgPSBbXVxuXHRcdG15Y29sID0gMSArIEBkcmFnICUgMlxuXHRcdG90aGVyID0gWzAsMiwxXVtteWNvbF1cblx0XHRmb3IgZGkgaW4gWy0xLDAsMV1cblx0XHRcdGZvciBkaiBpbiBbLTEsMCwxXVxuXHRcdFx0XHRpZiBub3QgKGRpPT0wIGFuZCBkaj09MClcblx0XHRcdFx0XHRpMT1pK2RpXG5cdFx0XHRcdFx0ajE9aitkalxuXHRcdFx0XHRcdHRlbXAgPSBbXVxuXHRcdFx0XHRcdHdoaWxlIDAgPD0gaTEgPCA4IGFuZCAwIDw9IGoxIDwgOCBhbmQgQGJvYXJkW2oxXVtpMV0gPT0gb3RoZXJcblx0XHRcdFx0XHRcdHRlbXAucHVzaCBbaTEsajFdXG5cdFx0XHRcdFx0XHRpMSA9IGkxK2RpXG5cdFx0XHRcdFx0XHRqMSA9IGoxK2RqXG5cdFx0XHRcdFx0aWYgMCA8PSBpMSA8IDggYW5kIDAgPD0gajEgPCA4IGFuZCBAYm9hcmRbajFdW2kxXSA9PSBteWNvbFxuXHRcdFx0XHRcdFx0aWYgdGVtcC5sZW5ndGggPiAwIHRoZW5cdHJlcyA9IHJlcy5jb25jYXQgdGVtcFxuXHRcdGlmIHJlcy5sZW5ndGggPiAwXG5cdFx0XHRAYm9hcmRbal1baV0gPSBteWNvbFxuXHRcdFx0Zm9yIFtpLGpdIGluIHJlcyB0aGVuXHRAYm9hcmRbal1baV0gPSBteWNvbFxuXHRcdFx0QGRyYWcrK1xuXHRtb3VzZVByZXNzZWQgOiAobXgsbXkpIC0+XG5cdFx0aSA9IGludCBteCAvIDIwIC0gMVxuXHRcdGogPSBpbnQgbXkgLyAyMCAtIDFcblx0XHRpZiAwIDw9IGkgPCA4IGFuZCAwIDw9IGogPCA4IGFuZCBAYm9hcmRbal1baV0gPT0gMCB0aGVuIEBtb3ZlIGksalxuXG5hcHAgPSBuZXcgUmV2ZXJzaSBcImFcIlxuXCJcIlwiXG5cdGM6XG5cdFx0YXBwIDogXCJyZXNldCgpXCJcblx0ZTpcblx0XHRSZXZlcnNpIDogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZXZlcnNpXCJcblxuSURfUm90YXRlZEVsbGlwc2UgPVxuXHR2OicyMDE3LTA0LTI5J1xuXHRiOlwiIyBMT0M6NSByZCAjIGVsbGlwc2UgdHJhbnNsYXRlXFxuXCJcblx0YTpcIlwiXCJcbmZjIDEsMCwwXG5zYygpXG50cmFuc2xhdGUgMTAwLDEwMFxucmQgNDVcbmVsbGlwc2UgMCwwLCA4MCw0MFxuXCJcIlwiXG5cbklEX1JvdGF0ZWRSZWN0QSA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCIjIExPQzo0IGZjICMgcmVjdFxcblwiXG5cdGE6XCJcIlwiXG5mYyAxLDAsMFxucmVjdCA2MCwxMDAsIDQwLDQwXG5mYyAwLDEsMFxucmVjdCAxNDAsMTAwLCA0MCw0MFxuXCJcIlwiXG5cbklEX1JvdGF0ZWRSZWN0QiA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCIjIExPQzoxMiBmYyByZCAjIHJlY3QgdHJhbnNsYXRlIHB1c2ggcG9wXFxuXCJcblx0YTpcIlwiXCJcbnB1c2goKVxuZmMgMSwwLDBcbnRyYW5zbGF0ZSA2MCwxMDBcbnJkIDQ1XG5yZWN0IDAsMCwgNDAsNDBcbnBvcCgpXG5wdXNoKClcbmZjIDAsMSwwXG50cmFuc2xhdGUgMTQwLDEwMFxucmQgNDVcbnJlY3QgMCwwLCA0MCw0MFxucG9wKClcblwiXCJcIlxuXG5JRF9Sb3RhdGVkUmVjdEMgPVxuXHR2OicyMDE3LTA0LTI5J1xuXHRiOlwiIyBMT0M6MTMgZmMgcmQgIyByZWN0IHRyYW5zbGF0ZSBwdXNoIHBvcFxcblwiXG5cdGE6XCJcIlwiXG5yZWN0TW9kZSBDRU5URVJcbnB1c2goKVxuZmMgMSwwLDBcbnRyYW5zbGF0ZSA4MCwxMjBcbnJkIDQ1XG5yZWN0IDAsMCwgNDAsNDBcbnBvcCgpXG5wdXNoKClcbmZjIDAsMSwwXG50cmFuc2xhdGUgMTYwLDEyMFxucmQgNDVcbnJlY3QgMCwwLCA0MCw0MFxucG9wKClcblwiXCJcIlxuXG5JRF9Sb3VsZXR0ZSA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCJcIlwiXG4jIExPQzoxNSBiZyBzdyBmYyBzYyByYW5nZSByZCAjIGZvciBpbiBpZiB0aGVuIGVsc2UgPT0gJSAvIFtdIFwiXCIgUElcbiMgICAgICAgIGxlbmd0aCB0ZXh0IHRleHRBbGlnbiBhcmMgc3Ryb2tlQ2FwIHRyYW5zbGF0ZSBwdXNoIHBvcFxuXG5udW1iZXJzID0gWzAsMzIsMTUsMTksNCwyMSwyLDI1LDE3LDM0LDYsMjcsMTMsMzYsMTEsMzAsOCwyMywxMCw1LDI0LDE2LDMzLDEsMjAsMTQsMzEsOSwyMiwxOCwyOSw3LDI4LDEyLDM1LDMsMjZdXG5cIlwiXCJcblx0YTpcIlwiXCJcbm51bWJlcnMgPSBbMCwzMiwxNSwxOSw0LDIxLDIsMjUsMTcsMzQsNiwyNywxMywzNiwxMSwzMCw4LDIzLDEwLDUsMjQsMTYsMzMsMSwyMCwxNCwzMSw5LDIyLDE4LDI5LDcsMjgsMTIsMzUsMywyNl1cbmJnIDAuNVxudHJhbnNsYXRlIDEwMCwxMDBcbmQgPSBQSS9udW1iZXJzLmxlbmd0aFxuc3cgMjBcbnN0cm9rZUNhcCBTUVVBUkVcbnRleHRBbGlnbiBDRU5URVIsQ0VOVEVSXG5mb3IgbnVtYmVyLGkgaW4gbnVtYmVyc1xuXHRmYygpXG5cdGlmIGk9PTAgdGhlbiBzYyAwLDEsMCBlbHNlIHNjIGklMiwwLDBcblx0YXJjIDAsMCwxODAsMTgwLC1QSS8yLWQsLVBJLzIrZFxuXHRzYygpXG5cdGZjIDFcblx0dGV4dCBudW1iZXIsMCwtOTBcblx0cmQgMzYwIC8gbnVtYmVycy5sZW5ndGhcblwiXCJcIlxuXHRlIDpcblx0XHRXaWtpcGVkaWEgOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvdWxldHRlXCJcblxuSURfUnViaWtDdWJlID1cblx0djonMjAxNy0wNC0yOSdcblx0YjpcIlwiXCJcbiMgTE9DOjEyMSBiZyBmYyBzYyByYW5nZSAjIFtdIHB1c2ggcG9wIGNvbmNhdCBsZW5ndGggaWYgdGhlbiBlbHNlIGNvbnN0cmFpbiBmb3IgaW4gaW50IHF1YWRcbiMgICAgICAgICB0ZXh0IHRleHRTaXplIHRleHRBbGlnbiBkaXN0ICsgLSAqIC8gY2xhc3MgZXh0ZW5kcyBjb25zdHJ1Y3RvciBuZXcgQCBzdXBlciAtPlxuXG5jbGFzcyBSdWJpa0N1YmUgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0ZHJhdyA6IC0+XG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT5cblx0dG9nZ2xlTnVtYmVycyA6IC0+XG5hcHAgPSBuZXcgUnViaWtDdWJlXG5cIlwiXCJcblx0YTpcIlwiXCJcbmNsYXNzIFJ1YmlrQ3ViZSBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdG5ld0dhbWUgOiAtPlxuXHRcdEBsZXZlbCA9IEBsZXZlbCArIGlmIEBsZXZlbD09QGhpc3RvcnkubGVuZ3RoIHRoZW4gMSBlbHNlIC0xXG5cdFx0QGxldmVsID0gY29uc3RyYWluIEBsZXZlbCwwLDEwMFxuXHRcdEBoaXN0b3J5ID0gW11cblx0XHRAYm9hcmQgPSBbXVxuXHRcdEBtZW1vcnkgPSAtMVxuXHRcdEBib2FyZC5wdXNoIGkgZm9yIGkgaW4gcmFuZ2UgNTRcblx0XHRmb3IgaSBpbiByYW5nZSBAbGV2ZWxcblx0XHRcdEBvcCBAcmFuZGludCg2KSwgMipAcmFuZGludCgyKS0xXG5cdHJhbmRpbnQgOiAobikgLT4gaW50IG4gKiBmcmFjdGlvbiAxMDAwMCAqIE1hdGguc2luIEBzZWVkKytcblx0dW5kbyA6IC0+XG5cdFx0aWYgQGhpc3RvcnkubGVuZ3RoPT0wIHRoZW4gcmV0dXJuXG5cdFx0QG1lbW9yeSA9IC0xXG5cdFx0W2ssZF0gPSBAaGlzdG9yeS5wb3AoKVxuXHRcdEBvcCBrLC1kXG5cdHR1cm4gOiAoYSxiKSAtPiAjIGEsYiBpbiAwLi41NFxuXHRcdGlmIGludChhLzkpICE9IGludChiLzkpIHRoZW4gcmV0dXJuXG5cdFx0ZCA9IChhJTkgLSBiJTkpLzJcblx0XHRpZiBkIGluIFstMywzXSB0aGVuIGQgPSAtZC8zXG5cdFx0aWYgZCBub3QgaW4gWy0xLDFdIHRoZW4gcmV0dXJuXG5cdFx0ayA9IGludCBhLzlcblx0XHRAb3AgayxkXG5cdFx0QGhpc3RvcnkucHVzaCBbayxkXVxuXHRvcCA6IChrLGQpIC0+ICMgMC4uNSwgWy0xLDFdXG5cdFx0dGlsZXMgPSBbXG5cdFx0XHRbMCwxLDQyLDQxLDQwLCAgIDIsMyw5LDE2LDE1LCAgICA0LDUsMjAsMTksMTgsICAgNiw3LDMxLDMwLDI5XVxuXHRcdFx0WzksMTAsNDAsMzksMzgsICAxMSwxMiw0OSw0OCw0NywgMTMsMTQsMjIsMjEsMjAsIDE1LDE2LDQsMywyXVxuXHRcdFx0WzE4LDE5LDYsNSw0LCAgICAyMCwyMSwxNSwxNCwxMywgMjIsMjMsNDcsNDYsNDUsIDI0LDI1LDMzLDMyLDMxXVxuXHRcdFx0WzI3LDI4LDM2LDQzLDQyLCAyOSwzMCwwLDcsNiwgICAgMzEsMzIsMTgsMjUsMjQsIDMzLDM0LDQ1LDUyLDUxXVxuXHRcdFx0WzM2LDM3LDUxLDUwLDQ5LCAzOCwzOSwxMSwxMCw5LCAgNDAsNDEsMiwxLDAsICAgIDQyLDQzLDI5LDI4LDI3XVxuXHRcdFx0WzQ1LDQ2LDI0LDIzLDIyLCA0Nyw0OCwxMywxMiwxMSwgNDksNTAsMzgsMzcsMzYsIDUxLDUyLDI3LDM0LDMzXV1cblx0XHRhcnIgPSB0aWxlc1trXVxuXHRcdGNhcnIgPSAoQGJvYXJkW2ldIGZvciBpIGluIGFycilcblx0XHRsaW1pdCA9IGlmIGQ9PTEgdGhlbiA1IGVsc2UgMTVcblx0XHRjYXJyID0gY2FycltsaW1pdC4uMjBdLmNvbmNhdCBjYXJyWzAuLmxpbWl0XVxuXHRcdEBib2FyZFthcnJbaV1dID0gY2FycltpXSBmb3IgaSBpbiByYW5nZSAyMFxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0XHRAYm9hcmQgPSBbXVxuXHRcdEBtZW1vcnkgPSAtMVxuXHRcdEBsZXZlbCA9IC0xXG5cdFx0QGhpc3RvcnkgPSBbXVxuXHRcdEBidXR0b25zID0gW1s0MCwxNDAsQGxldmVsXSwgWzE2MCwxNDAsXCJuZXdcIl1dXG5cdFx0QHNob3dOdW1iZXJzID0gZmFsc2Vcblx0XHRAc2VlZCA9IDBcblx0XHRAbmV3R2FtZSgpXG5cdGNvbG9yaXplIDogKGluZGV4LGJvYXJkKSAtPlxuXHRcdGsgPSBpbnQgYm9hcmRbaW5kZXhdIC8gOVxuXHRcdFtyLGcsYl0gPSBbWzEsMSwxXSxbMCwwLDFdLFsxLDAsMF0sWzAsMSwwXSxbMC45NywgMC41NywgMF0sWzEsMSwwXV1ba11cblx0XHRmYyByLGcsYlxuXHR0ZXh0Q29sb3JpemUgOiAoaW5kZXgsYm9hcmQpIC0+IGZjIFswLDEsMSwwLDAsMF1baW50IGJvYXJkW2luZGV4XSAvIDldXG5cdHJpdGEgOiAoeCx5LGluZGV4LHRpbHQsc2VsZikgLT5cblx0XHRhID0gMTZcblx0XHRiID0gOVxuXHRcdHNlbGYuY29sb3JpemUgaW5kZXgsc2VsZi5ib2FyZFxuXHRcdHNjIDBcblx0XHRpZiB0aWx0ID09IDAgdGhlbiBxdWFkIHgtYSx5LCB4LHktYiwgeCthLHksIHgseStiXG5cdFx0aWYgdGlsdCA9PSAxIHRoZW4gcXVhZCB4K2EvMix5LWIvMiwgeC1hLzIseS0zKmIvMiwgeC1hLzIseStiLzIsIHgrYS8yLHkrMypiLzJcblx0XHRpZiB0aWx0ID09IDIgdGhlbiBxdWFkIHgtYS8yLHktYi8yLCB4K2EvMix5LTMqYi8yLCB4K2EvMix5K2IvMiwgeC1hLzIseSszKmIvMlxuXHRcdHNlbGYudGV4dENvbG9yaXplIGluZGV4LHNlbGYuYm9hcmRcblx0XHRzYygpXG5cdFx0aWYgc2VsZi5zaG93TnVtYmVycyB0aGVuIHRleHQgc2VsZi5ib2FyZFtpbmRleF0seCx5XG5cdFx0aWYgc2VsZi5tZW1vcnk/IGFuZCBpbmRleCA9PSBzZWxmLm1lbW9yeSB0aGVuIGNpcmNsZSB4LHksNFxuXHRcdGZhbHNlXG5cdHNlbnNlIDogKHgseSxpbmRleCx0aWx0LHNlbGYpIC0+IGRpc3QoeCx5LG1vdXNlWCxtb3VzZVkpIDwgOVxuXHRkcmF3IDogLT5cblx0XHRiZyAwXG5cdFx0dGV4dFNpemUgMTJcblx0XHR0ZXh0QWxpZ24gQ0VOVEVSLENFTlRFUlxuXHRcdEB0cmF2ZXJzZSBAcml0YVxuXHRcdGZjIDEsMSwwXG5cdFx0dGV4dFNpemUgMjBcblx0XHRAYnV0dG9uc1swXVsyXSA9IEBsZXZlbCAtIEBoaXN0b3J5Lmxlbmd0aFxuXHRcdHRleHQgdHh0LHgseSBmb3IgW3gseSx0eHRdIGluIEBidXR0b25zXG5cdHRyYXZlcnNlIDogKGYpIC0+XG5cdFx0YSA9IDE2XG5cdFx0YiA9IDlcblx0XHR5MCA9IDYwXG5cdFx0Zm9yIGluZGV4IGluIHJhbmdlIDU0XG5cdFx0XHRzaWRlID0gaW50IGluZGV4IC8gOVxuXHRcdFx0aWYgc2lkZT09MCAjIHZpdFxuXHRcdFx0XHRpID0gWy0xLC0xLC0xLDAsMSwxLDEsMCwwXVtpbmRleCAlIDldXG5cdFx0XHRcdGogPSBbMCwxLDIsMiwyLDEsMCwwLDFdW2luZGV4ICUgOV1cblx0XHRcdFx0aWYgZiAxMDArYSooaStqLTEpLHkwK2IqKGktaisxKSwgaW5kZXgsIDAsQCB0aGVuIHJldHVybiBpbmRleFxuXHRcdFx0aWYgc2lkZT09MSAjIGJsw6Vcblx0XHRcdFx0aSA9IFstMSwtMSwtMSwwLDEsMSwxLDAsMF1baW5kZXggJSA5XVxuXHRcdFx0XHRqID0gWzAsMSwyLDIsMiwxLDAsMCwxXVtpbmRleCAlIDldXG5cdFx0XHRcdGlmIGYgMTAwK2EqKGkrNC41KSx5MCtiKigyKmoraS0zLjUpLCBpbmRleCwgMSxAIHRoZW4gcmV0dXJuIGluZGV4XG5cdFx0XHRpZiBzaWRlPT0yICMgcsO2ZFxuXHRcdFx0XHRpID0gWy0xLDAsMSwxLDEsMCwtMSwtMSwwXVtpbmRleCAlIDldXG5cdFx0XHRcdGogPSBbMCwwLDAsMSwyLDIsMiwxLDFdW2luZGV4ICUgOV1cblx0XHRcdFx0aWYgZiAxMDArYSooaSsxLjUpLHkwK2IqKDIqai1pKzIuNSksIGluZGV4LCAyLEAgdGhlbiByZXR1cm4gaW5kZXhcblx0XHRcdGlmIHNpZGU9PTMgIyBncsO2blxuXHRcdFx0XHRpID0gWy0xLC0xLC0xLDAsMSwxLDEsMCwwXVtpbmRleCAlIDldXG5cdFx0XHRcdGogPSBbMiwxLDAsMCwwLDEsMiwyLDFdW2luZGV4ICUgOV1cblx0XHRcdFx0aWYgZiAxMDArYSooaS0xLjUpLHkwK2IqKDIqaitpKzIuNSksIGluZGV4LCAxLEAgdGhlbiByZXR1cm4gaW5kZXhcblx0XHRcdGlmIHNpZGU9PTQgIyBvcmFuZ2Vcblx0XHRcdFx0aSA9IFstMSwgMCwgMSwgMSwgMSwgMCwtMSwtMSwgMF1baW5kZXggJSA5XVxuXHRcdFx0XHRqID0gWyAyLCAyLCAyLCAxLCAwLCAwLCAwLCAxLCAxXVtpbmRleCAlIDldXG5cdFx0XHRcdGlmIGYgMTAwK2EqKGktNC41KSx5MCtiKigyKmotaS0zLjUpLCBpbmRleCwgMixAIHRoZW4gcmV0dXJuIGluZGV4XG5cdFx0XHRpZiBzaWRlPT01ICMgZ3VsXG5cdFx0XHRcdGkgPSBbIDEsIDEsIDEsIDAsLTEsLTEsLTEsIDAsIDBdW2luZGV4ICUgOV1cblx0XHRcdFx0aiA9IFsgMCwgMSwgMiwgMiwgMiwgMSwgMCwgMCwgMV1baW5kZXggJSA5XVxuXHRcdFx0XHRpZiBmIDEwMCthKihpK2otMSkseTArYiooaS1qKzEzKSwgaW5kZXgsIDAsQCB0aGVuIHJldHVybiBpbmRleFxuXHRcdC0xXG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT5cblx0XHRmb3IgW3gseSx0eHRdLGkgaW4gQGJ1dHRvbnNcblx0XHRcdGlmIGRpc3QobXgsbXkseCx5KSA8IDEwXG5cdFx0XHRcdGlmIGk9PTAgdGhlbiByZXR1cm4gQHVuZG8oKVxuXHRcdFx0XHRpZiBpPT0xIHRoZW4gcmV0dXJuIEBuZXdHYW1lKClcblx0XHRpZiBAbWVtb3J5ID09IC0xXG5cdFx0XHRAbWVtb3J5ID0gQHRyYXZlcnNlIEBzZW5zZVxuXHRcdFx0aWYgQG1lbW9yeSAhPSAtMVxuXHRcdFx0XHRpZiBAbWVtb3J5JTk9PTggdGhlbiBAbWVtb3J5ID0gLTFcblx0XHRlbHNlXG5cdFx0XHRpbmRleCA9IEB0cmF2ZXJzZSBAc2Vuc2Vcblx0XHRcdGlmIGluZGV4ICE9IC0xIGFuZCBpbmRleCU5ICE9IDggdGhlbiBAdHVybiBAbWVtb3J5LGluZGV4XG5cdFx0XHRAbWVtb3J5ID0gLTFcblx0dG9nZ2xlTnVtYmVycyA6IC0+XG5cdFx0QHNob3dOdW1iZXJzID0gbm90IEBzaG93TnVtYmVyc1xuXG5hcHAgPSBuZXcgUnViaWtDdWJlIFwiYVwiXG5cblxuXCJcIlwiXG5cdGM6XG5cdFx0YXBwIDogXCJyZXNldCgpfHRvZ2dsZU51bWJlcnMoKVwiXG5cdGU6XG5cdFx0XCJSdWJpa0N1YmVcIiA6IFwiaHR0cHM6Ly9zdi53aWtpcGVkaWEub3JnL3dpa2kvUnViaWtzX2t1YlwiXG5cbklEX1J1YmlrU3F1YXJlID1cblx0djonMjAxNy0wNC0yOSdcblx0YjpcIlwiXCJcbiMgTE9DOjg1IGJnIGZjIHNjIGNpcmNsZSAjIFtdIHB1c2ggbGVuZ3RoIGludCAuLiArIC0gKiAvICUgJSUgPT0gPCAmIDw8IGlmIHRoZW4gZWxzZSByZWN0TW9kZSByZWN0IHB1c2ggcG9wIG5vdCBcIlwiIHNwbGl0IGpvaW5cbiMgICAgICAgIHBhcnNlSW50IF8uaXNFcXVhbCB0ZXh0IHRleHRBbGlnbiB0ZXh0U2l6ZSByZWN0TW9kZSB3aGlsZSBhbmQgY29uc3RyYWluIGNsYXNzIGV4dGVuZHMgY29uc3RydWN0b3IgbmV3IEAgc3VwZXIgLT5cbiMgT0JTOiBEdSBiw7ZyIGFudsOkbmRhIHZhcmlhYmVsbiBydWJpa1NxdWFyZURhdGEuXG5cbmNsYXNzIFJ1YmlrU3F1YXJlIGV4dGVuZHMgQXBwbGljYXRpb25cblx0cmVzZXQgOiAtPlxuXHRkcmF3IDogLT5cblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuYXBwID0gbmV3IFJ1YmlrU3F1YXJlXG5cIlwiXCJcblx0YTpcIlwiXCJcbmNsYXNzIFJ1YmlrU3F1YXJlIGV4dGVuZHMgQXBwbGljYXRpb25cblx0cmVzZXQgOiAtPlxuXHRcdHN1cGVyXG5cdFx0QEJVVFRPTlMgPSBbWzQsMywzLDNdLFsxMCwzLDMsM10sWzE2LDMsMywzXSwgWzQsOSwzLDNdLFsxMCw5LDMsM10sWzE2LDksMywzXSwgWzQsMTUsMywzXSxbMTAsMTUsMywzXSxbMTYsMTUsMywzXSwgWzQsMTksMywxXSxbMTAsMTksMywxXSxbMTYsMTksMywxXV1cblx0XHRAc2VlZCA9IDBcblx0XHRAbGV2ZWwgPSAxXG5cdFx0QGhpc3RvcnkgPSBbXVxuXHRcdEBtZW1vcnkgPSAtMVxuXHRcdEBjcmVhdGVHYW1lKClcblxuXHRyYW5kaW50IDogKG4pIC0+IGludCBuICogZnJhY3Rpb24gMTAwMDAgKiBNYXRoLnNpbiBAc2VlZCsrXG5cblx0bmV3R2FtZSA6IC0+XG5cdFx0aWYgQGxldmVsID49IEBoaXN0b3J5Lmxlbmd0aCBhbmQgXy5pc0VxdWFsIEBib2FyZCxbMCwxLDIsMCwxLDIsMCwxLDJdIHRoZW4gZD0xIGVsc2UgZD0tMVxuXHRcdEBsZXZlbCA9IGNvbnN0cmFpbiBAbGV2ZWwrZCwxLDZcblx0XHRAaGlzdG9yeSA9IFtdXG5cdFx0QGNyZWF0ZUdhbWUoKVxuXG5cdGNyZWF0ZUdhbWUgOiAtPlxuXHRcdGJpZ3N0cmluZyA9IHJ1YmlrU3F1YXJlRGF0YVtAbGV2ZWxdXG5cdFx0YXJyID0gYmlnc3RyaW5nLnNwbGl0ICcgJ1xuXHRcdHMgPSBhcnJbQHJhbmRpbnQoYXJyLmxlbmd0aCldXG5cdFx0QGJvYXJkID0gKHBhcnNlSW50KGNoKSBmb3IgY2ggaW4gcylcblxuXHRtb3ZlIDogKG0sZCxib2FyZCkgLT5cblx0XHRbaSxqLGtdID0gW1swLDEsMl0sWzMsNCw1XSxbNiw3LDhdLFswLDMsNl0sWzEsNCw3XSxbMiw1LDhdXVttXVxuXHRcdGJkID0gYm9hcmRbLi5dXG5cdFx0W2EsYixjXSA9IFtiZFtpXSxiZFtqXSxiZFtrXV1cblx0XHRpZiBkPT0wIHRoZW4gW2EsYixjXSA9IFtiLGMsYV0gZWxzZSBbYSxiLGNdID0gW2MsYSxiXVxuXHRcdFtiZFtpXSxiZFtqXSxiZFtrXV0gPSBbYSxiLGNdXG5cdFx0YmRcblxuXHRkcmF3IDogLT5cblx0XHRiZyAwXG5cdFx0dGV4dEFsaWduIENFTlRFUixDRU5URVJcblx0XHR0ZXh0U2l6ZSAyMFxuXHRcdHJlY3RNb2RlIENFTlRFUixDRU5URVJcblx0XHRmb3IgYyxpIGluIEBib2FyZFxuXHRcdFx0c2MgMVxuXHRcdFx0aWYgYz09MCB0aGVuIGZjIDEsMCwwXG5cdFx0XHRpZiBjPT0xIHRoZW4gZmMgMCwxLDBcblx0XHRcdGlmIGM9PTIgdGhlbiBmYyAwLDAsMVxuXHRcdFx0W3gseSx3LGhdID0gQEJVVFRPTlNbaV1cblx0XHRcdHJlY3QgMTAqeCwxMCp5LDIwKncsMjAqaFxuXHRcdGlmIEBtZW1vcnkgPj0gMFxuXHRcdFx0W3gseSx3LGhdID0gQEJVVFRPTlNbQG1lbW9yeV1cblx0XHRcdGZjIDBcblx0XHRcdHNjKClcblx0XHRcdGNpcmNsZSAxMCp4LDEwKnksMTBcblx0XHRbeCx5LHcsaF0gPSBAQlVUVE9OU1sxMF1cblx0XHRmYyAxLDEsMFxuXHRcdHNjKClcblx0XHR0ZXh0IEBsZXZlbC1AaGlzdG9yeS5sZW5ndGgsMTAqeCwxMCp5XG5cdFx0aWYgQGhpc3RvcnkubGVuZ3RoID4gMFxuXHRcdFx0W3gseSx3LGhdID0gQEJVVFRPTlNbOV1cblx0XHRcdHRleHQgXCJ1bmRvXCIsMTAqeCwxMCp5XG5cdFx0XHRbeCx5LHcsaF0gPSBAQlVUVE9OU1sxMV1cblx0XHRcdHRleHQgXCJuZXdcIiwxMCp4LDEwKnlcblxuXHR1bmRvIDogLT5cblx0XHRpZiBAaGlzdG9yeS5sZW5ndGggPT0gMCB0aGVuIHJldHVyblxuXHRcdEBib2FyZCA9IEBoaXN0b3J5LnBvcCgpXG5cdFx0QG1lbW9yeSA9IC0xXG5cblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuXHRcdGluZGV4ID0gLTFcblx0XHRmb3IgW3gseSx3LGhdLGkgaW4gQEJVVFRPTlNcblx0XHRcdGlmIHgtdyA8PSBteC8xMCA8PSB4K3cgYW5kIHktaCA8PSBteS8xMCA8PSB5K2ggdGhlbiBpbmRleCA9IGlcblx0XHRpZiAwIDw9IGluZGV4IDwgOVxuXHRcdFx0aWYgQG1lbW9yeSA9PSAtMVxuXHRcdFx0XHRAbWVtb3J5ID0gaW5kZXhcblx0XHRcdGVsc2UgaWYgQG1lbW9yeSA9PSBpbmRleFxuXHRcdFx0XHRAbWVtb3J5ID0gLTFcblx0XHRcdGVsc2Vcblx0XHRcdFx0aGFzaCA9XG5cdFx0XHRcdFx0XCIwMVwiOlswLDFdLCBcIjAyXCI6WzAsMF0sIFwiMTBcIjpbMCwwXSwgXCIxMlwiOlswLDFdLCBcIjIwXCI6WzAsMV0sIFwiMjFcIjpbMCwwXVxuXHRcdFx0XHRcdFwiMzRcIjpbMSwxXSwgXCIzNVwiOlsxLDBdLCBcIjQzXCI6WzEsMF0sIFwiNDVcIjpbMSwxXSwgXCI1M1wiOlsxLDFdLCBcIjU0XCI6WzEsMF1cblx0XHRcdFx0XHRcIjY3XCI6WzIsMV0sIFwiNjhcIjpbMiwwXSwgXCI3NlwiOlsyLDBdLCBcIjc4XCI6WzIsMV0sIFwiODZcIjpbMiwxXSwgXCI4N1wiOlsyLDBdXG5cdFx0XHRcdFx0XCIwM1wiOlszLDFdLCBcIjA2XCI6WzMsMF0sIFwiMzBcIjpbMywwXSwgXCIzNlwiOlszLDFdLCBcIjYwXCI6WzMsMV0sIFwiNjNcIjpbMywwXVxuXHRcdFx0XHRcdFwiMTRcIjpbNCwxXSwgXCIxN1wiOls0LDBdLCBcIjQxXCI6WzQsMF0sIFwiNDdcIjpbNCwxXSwgXCI3MVwiOls0LDFdLCBcIjc0XCI6WzQsMF1cblx0XHRcdFx0XHRcIjI1XCI6WzUsMV0sIFwiMjhcIjpbNSwwXSwgXCI1MlwiOls1LDBdLCBcIjU4XCI6WzUsMV0sIFwiODJcIjpbNSwxXSwgXCI4NVwiOls1LDBdXG5cdFx0XHRcdHBhaXIgPSBoYXNoW1wiXCIgKyBAbWVtb3J5ICsgaW5kZXhdXG5cdFx0XHRcdGlmIHBhaXJcblx0XHRcdFx0XHRbbSxkXSA9IHBhaXJcblx0XHRcdFx0XHRAaGlzdG9yeS5wdXNoIEBib2FyZFsuLl1cblx0XHRcdFx0XHRAYm9hcmQgPSBAbW92ZSBtLGQsQGJvYXJkXG5cdFx0XHRcdFx0QG1lbW9yeSA9IC0xXG5cdFx0aWYgaW5kZXg9PTkgdGhlbiBAdW5kbygpXG5cdFx0aWYgaW5kZXg9PTExIHRoZW4gQG5ld0dhbWUoKVxuXG5hcHAgPSBuZXcgUnViaWtTcXVhcmUgXCJhXCJcblxuXCJcIlwiXG5cdGM6XG5cdFx0YXBwIDogXCJyZXNldCgpXCJcblxuSURfUnVzaEhvdXIgPVxuXHR2OicyMDE3LTA0LTI5J1xuXHRiOlwiXCJcIlxuIyBMT0M6NzEgYmcgc2MgZmMgcmFuZ2UgIyAvICUgKyAqIC0gPT0gPj0gKysgLS0gXCJcIiBbXSB7fSBwdXNoIGNsYXNzIGV4dGVuZHMgY29uc3RydWN0b3IgbmV3IEAgc3VwZXIgLT5cbiMgICAgICAgIHJlY3QgdGV4dCB0ZXh0QWxpZ24gZm9yIGluIGlmIHRoZW4gZWxzZSB0b0xvd2VyQ2FzZSBpbmRleE9mIF8uY3JlYXRlIHByb3RvdHlwZSBsZW5ndGggQHJlYWRUZXh0XG5cbiMgRGUgMzYgcnV0b3JuYSBudW1yZXJhczpcbiMgICAwIDEgMiAzIDQgNVxuIyAgIDYgNyA4IDkgYSBiXG4jICAgYyBkIGUgZiBnIGhcbiMgICBpIGogayBsIG0gblxuIyAgIG8gcCBxIHIgcyB0XG4jICAgdSB2IHcgeCB5IHpcbiNcbiMgUGxhY2VyaW5nIGF2IGZvcmRvbjpcbiMgICBob3Jpc29udGVsbHQ6IEE9MiBCPTNcbiMgICB2ZXJ0aWthbHQ6ICAgIEM9MiBEPTNcbiNcbiMgTMO2c25pbmdhcjpcbiMgXHRCaWxhcm5hIG5hbW5nZXMgaSBmw7ZsamRlbiBYQUJDREVGR0hJSktMTU5PUFFSXG4jIFx0bGl0ZW4gYm9rc3RhdjogdsOkbnN0ZXIvdXBww6V0XG4jIFx0c3RvciBib2tzdGF2OiAgaMO2Z2VyL25lZMOldFxuXG5jbGFzcyBDYXJcblx0Y29uc3RydWN0b3IgOiAoY2gsd2gsQGMpIC0+XG5cdHJlbmRlciAgICAgIDogLT5cblx0bW92ZSAgICAgICAgOiAoZCkgLT5cblxuY2xhc3MgUnVzaEhvdXIgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRjbGFzc2VzICAgIDogLT4gW0Nhcl1cblx0cmVzZXQgICAgICA6IC0+XG5cdFx0c3VwZXJcblx0ZHJhdyAgICAgICA6IC0+XG5cdGVudGVyX2NhcnMgOiAtPiAjIEFkMHNCd0NvRDU2OVxuXHRlbnRlcl9tb3ZlIDogLT4gIyBiYmJFRUVBZmRjY0dHWFhYWFhcblx0YmVnaW4gICAgICA6IC0+XG5cdGJhY2t3YXJkICAgOiAobj0xKSAtPlxuXHRmb3J3YXJkICAgIDogKG49MSkgLT5cblx0ZW5kICAgICAgICA6IC0+XG5hcHAgPSBuZXcgUnVzaEhvdXJcblxuXCJcIlwiXG5cdGE6XCJcIlwiXG5jbGFzcyBDYXJcblx0Y29uc3RydWN0b3IgOiAoY2gsd2gsQGMpIC0+XG5cdFx0aW5kZXggPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLmluZGV4T2YgY2hcblx0XHRAaSA9IGluZGV4ICUgNlxuXHRcdEBqID0gaW50IGluZGV4IC8gNlxuXHRcdFtAdyxAaF0gPSB3aFxuXG5cdHJlbmRlciA6IC0+XG5cdFx0ZmNjIChAYysxKSAlIDhcblx0XHRyZWN0IDQwKzIwKkBpKzIsIDQwKzIwKkBqKzIsIDIwKkB3LTQsIDIwKkBoLTRcblx0XHRmYyAwXG5cdFx0dGNjIChAYysxKSAlIDhcblx0XHRuYW1lID0gXCJYQUJDREVGR0hJSktMTU5PUFwiW0BjXVxuXHRcdHNtYWxsID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cdFx0dGV4dCBzbWFsbCwgNTArMjAqQGksICAgICAgICA1MCsyMCpAalxuXHRcdHRleHQgbmFtZSwgIDUwKzIwKihAaStAdy0xKSwgNTArMjAqKEBqK0BoLTEpXG5cblx0bW92ZSA6IChkKSAtPiAjIC0xIGVsbGVyICsxXG5cdFx0aWYgQHcgPT0gMSB0aGVuIEBqICs9IGRcblx0XHRpZiBAaCA9PSAxIHRoZW4gQGkgKz0gZFxuXG5jbGFzcyBSdXNoSG91ciBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdGNsYXNzZXMgOiAtPiBbQ2FyXVxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0XHRAZW50ZXJfY2FyczEgXCJBZDBzQndDb0Q1NjlcIlxuXHRcdEBlbnRlcl9tb3ZlMSBcImJiYkVFRUFmZGNjR0dYWFhYWFwiXG5cdFx0QGJlZ2luKClcblxuXHRkcmF3IDogLT5cblx0XHR0ZXh0QWxpZ24gQ0VOVEVSLENFTlRFUlxuXHRcdGJnIDBcblx0XHRzYygpXG5cdFx0ZmMgMC41XG5cdFx0cmVjdCA0MCw0MCwxMjAsMTIwXG5cdFx0cmVjdCAxNjAsODAsNDAsMjBcblx0XHRmYyAxXG5cdFx0c2MoKVxuXHRcdGZvciBpIGluIHJhbmdlIDZcblx0XHRcdHRleHQgXCIwMTIzNDVcIltpXSwzMCw1MCsyMCppXG5cdFx0XHR0ZXh0IFwiMDEyMzQ1XCJbaV0sNTArMjAqaSwxNzBcblx0XHRmb3IgY2FyIGluIEBjYXJzXG5cdFx0XHRjYXIucmVuZGVyKClcblxuXHRlbnRlcl9jYXJzIDogLT4gQGVudGVyX2NhcnMxIEByZWFkVGV4dCgpXG5cdGVudGVyX2NhcnMxIDogKHMpIC0+XG5cdFx0QGNhcnMgPSBbXVxuXHRcdEBtb3ZlcyA9IFwiXCJcblx0XHRAaW5kZXggPSAwXG5cdFx0Zm9yIGNoIGluIHNcblx0XHRcdGlmIGNoIGluIFwiQUJDRFwiIHRoZW4gd2ggPSB7QTpbMiwxXSwgQjpbMywxXSwgQzpbMSwyXSwgRDpbMSwzXX1bY2hdXG5cdFx0XHRlbHNlIEBjYXJzLnB1c2ggbmV3IENhciBjaCx3aCxAY2Fycy5sZW5ndGhcblxuXHRlbnRlcl9tb3ZlIDogLT4gQGVudGVyX21vdmUxIEByZWFkVGV4dCgpXG5cdGVudGVyX21vdmUxIDogKHMpIC0+XG5cdFx0QG1vdmVzID0gQG1vdmVzWy4uLkBpbmRleF1cblx0XHRAbW92ZXMgKz0gc1xuXHRcdEBmb3J3YXJkIHMubGVuZ3RoXG5cblx0YmVnaW4gOiAtPiBAYmFja3dhcmQgQGluZGV4XG5cdGJhY2t3YXJkIDogKG49MSkgLT5cblx0XHRmb3IgaSBpbiByYW5nZSBuXG5cdFx0XHRpZiBAaW5kZXggPT0gMCB0aGVuIHJldHVyblxuXHRcdFx0QGluZGV4LS1cblx0XHRcdEBib3Rod2FyZCBcIlhBQkNERUZHSElKS0xNTk9cIixcInhhYmNkZWZnaGlqa2xtbm9cIlxuXHRmb3J3YXJkIDogKG49MSkgLT5cblx0XHRmb3IgaSBpbiByYW5nZSBuXG5cdFx0XHRpZiBAaW5kZXggPj0gQG1vdmVzLmxlbmd0aCB0aGVuIHJldHVyblxuXHRcdFx0QGJvdGh3YXJkIFwieGFiY2RlZmdoaWprbG1ub1wiLFwiWEFCQ0RFRkdISUpLTE1OT1wiXG5cdFx0XHRAaW5kZXgrK1xuXHRlbmQgOiAtPiBAZm9yd2FyZCBAbW92ZXMubGVuZ3RoIC0gQGluZGV4XG5cblx0Ym90aHdhcmQgOiAoYSxiKSAtPlxuXHRcdGkgPSBhLmluZGV4T2YgQG1vdmVzW0BpbmRleF1cblx0XHRqID0gYi5pbmRleE9mIEBtb3Zlc1tAaW5kZXhdXG5cdFx0aWYgaSA+PSAwIHRoZW4gQGNhcnNbaV0ubW92ZSAtMVxuXHRcdGlmIGogPj0gMCB0aGVuIEBjYXJzW2pdLm1vdmUgKzFcblxuYXBwID0gbmV3IFJ1c2hIb3VyIFwiYVwiXG5cIlwiXCJcblx0Yzpcblx0XHRhcHAgOiBcInJlc2V0KCl8ZW50ZXJfY2FycygpfGVudGVyX21vdmUoKXxiZWdpbigpfGJhY2t3YXJkKCl8Zm9yd2FyZCgpfGVuZCgpXCIgIyB8aGludCgpfHVuZG8oKVxuXHRlOlxuXHRcdFJ1c2hIb3VyIDogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SdXNoX0hvdXJfKGJvYXJkX2dhbWUpXCJcblxuIl19
//# sourceURL=C:\github\p5Dojo\coffee\data\R.coffee