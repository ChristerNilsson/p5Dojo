// Generated by CoffeeScript 1.11.1
var ID_Cards, ID_ChessBoard, ID_ChessGame, ID_ChessRow, ID_ClickDetector, ID_CoffeescriptClock, ID_ColorCross, ID_ColorCube, ID_ColorPair, ID_Complex, ID_Connect4, ID_CornerPoints, ID_CornerPoints3, ID_CornerPoints7, ID_Counter, ID_Cross;

ID_Cards = {
  v: '2017-04-29',
  b: "# LOC:10 fc sc circle range rd # rect rectMode for in lerp translate\n",
  a: "rectMode CENTER\nsc 1\ntranslate 100,100\nfor i in range 18,-1,-1\n	r = 1.0*i/18\n	fc r,0,0\n	w = 70+5*i\n	h = 70+5*i\n	rect 0,0, w,h\n	rd 5"
};

ID_ChessBoard = {
  v: '2017-04-29',
  b: "# LOC:7 bg fc range # for in lerp rect\n",
  a: "bg 0.5\nfor i in range 8\n	for j in range 8\n		fc (i+j)%2\n		x = 20+20*i\n		y = 20+20*j\n		rect x,y, 20,20"
};

ID_ChessGame = {
  v: '2017-04-29',
  b: "# LOC:53 bg fc sc sw range circle # rectMode class constructor super extends new @\n#        rect if then else text textSize textAlign for in split length indexOf\n#        \"\" toUpperCase _.isEqual % + - * / <= == [] push pop length and not substr\n# OBS!   Rockad, en passant samt bondeförvandling hanteras ej.\n#        Flytta pjäserna med musen. Klick utanför brädet innebär undo.\n\nclass Chess extends Application\n	reset : ->\n		super\n	draw  : ->\n	mousePressed : (mx,my) ->\napp = new Chess",
  a: "class Chess extends Application\n	reset : ->\n		super\n		@SIZE = 22\n		@X = 100\n		@Y = 100\n		@board = ['RNBQKBNR','PPPPPPPP','........','........','........','........','pppppppp','rnbqkbnr']\n		@history = []\n		@memory = 0\n	draw : ->\n		bg 0.5\n		textSize 0.9 * @SIZE\n		textAlign CENTER,CENTER\n		rectMode CENTER\n		sc()\n		for i in range 8\n			for j in range 8\n				if (i+j)%2 == 0 then fc 0.6 else fc 0.8\n				x = @X-3.5*@SIZE+@SIZE*i\n				y = @Y-3.5*@SIZE+@SIZE*(7-j)\n				if _.isEqual @memory,[i,j] then fc 0,1,0\n				rect x,y, @SIZE, @SIZE\n				piece = @board[j][i]\n				if piece in \"RNBQKP\" then fc 0.95 else fc 0\n				if piece != '.'\n					if piece in \"pP\" then circle x,y,5 else text piece.toUpperCase(),x,y\n	setCharAt : (i,j,chr) ->\n    @board[j] = @board[j].substr(0,i) + chr + @board[j].substr(i+1)\n	move : (a,b) ->\n		[i1,j1] = a\n		[i2,j2] = b\n		taken = @board[j2][i2]\n		@setCharAt i2,j2, @board[j1][i1]\n		@setCharAt i1,j1,' '\n		@history.push [a,b,taken]\n	undo : () ->\n		if @history.length == 0 then return\n		[a,b,taken] = @history.pop()\n		[i1,j1] = a\n		[i2,j2] = b\n		@setCharAt i1,j1, @board[j2][i2]\n		@setCharAt i2,j2, taken\n	mousePressed : (mx,my) ->\n		i = int (mx-20)/20\n		j = 7 - int (my-20)/20\n		if 0 <= i <= 7 and 0 <= j <= 7\n			if @memory == 0\n				@memory = [i,j]\n			else\n				if not _.isEqual @memory,[i,j] then @move @memory,[i,j]\n				@memory = 0\n		else\n			@undo()\n\napp = new Chess \"a\"\n",
  c: {
    app: "reset()"
  }
};

ID_ChessRow = {
  v: '2017-04-29',
  b: "# LOC:5 bg fc range # % for in lerp rect\n",
  a: "bg 0.5\nfor i in range 8\n	fc i%2\n	x = 20+20*i\n	rect x,20, 20,20"
};

ID_ClickDetector = {
  v: '2017-04-29',
  b: "# LOC:62 bg sc fc range circle # quad rect triangle class extends constructor new @ super ->\n#        or and == dist reverse if then < and * / + - ++ text textAlign textSize rectMode\n\nclass Vector\n	constructor : (@x,@y) ->\n	add : (b) -> new Vector @x+b.x,@y+b.y\n	div : (n) -> new Vector @x/n,@y/n\n\nclass ClickDetector extends Application\n	reset : ->\n		super\n	draw  : ->\n	mousePressed : (mx,my) ->\napp = new ClickDetector",
  a: "class Vector # pga att p5.Vector krockar med min serialisering\n	constructor : (@x,@y) ->\n	add : (b) -> cv @x+b.x,@y+b.y\n	div : (n) -> cv @x/n,@y/n\ncv = (x,y) -> new Vector x,y\n\nclass Figure\n	constructor : (pc) ->\n		@pc = cv(int(pc.x),int(pc.y))\n		@counter = 0\n	draw : -> text @counter,@pc.x,@pc.y\n	detect : (bool) ->\n		if bool then @counter++\n		bool\n\nclass Circle extends Figure\n	constructor : (@p,@radius,@r,@g,@b) -> super @p\n	detect : (mx,my) -> super @radius > dist @p.x,@p.y,mx,my\n	draw : -> super circle @p.x,@p.y, @radius\n\nclass Rect extends Figure\n	constructor : (@p,@w,@h,@r,@g,@b) -> super @p\n	detect : (mx,my) -> super @p.x-@w/2 < mx < @p.x+@w/2 and @p.y-@h/2 < my < @p.y+@h/2\n	draw : -> super rect @p.x,@p.y,@w,@h\n\nclass Triangle extends Figure\n	constructor : (@v1,@v2,@v3,@r=0,@g=0,@b=0) -> super @v1.add(@v2).add(@v3).div(3)\n	detect : (mx,my) ->\n		pt = cv mx,my\n		sign = (p1,p2,p3) -> (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y)\n		b1 = 0 > sign pt, @v1, @v2\n		b2 = 0 > sign pt, @v2, @v3\n		b3 = 0 > sign pt, @v3, @v1\n		super b1 == b2 and b2 == b3\n	draw : -> super triangle @v1.x,@v1.y, @v2.x,@v2.y, @v3.x,@v3.y\n\nclass Quad extends Figure\n	constructor : (@v1,@v2,@v3,@v4, @r,@g,@b) -> super @v1.add(@v2).add(@v3).add(@v4).div(4)\n	detect : (mx,my) ->\n		t1 = new Triangle @v1,@v2,@v3\n		t2 = new Triangle @v1,@v3,@v4\n		super t1.detect(mx,my) or t2.detect(mx,my)\n	draw : -> super quad @v1.x,@v1.y, @v2.x,@v2.y, @v3.x,@v3.y, @v4.x,@v4.y\n\nclass ClickDetector extends Application\n	classes : -> [Vector,Circle,Rect,Triangle,Quad]\n	reset : ->\n		super\n		@figures = []\n		@figures.push new Circle cv(70,70), 50, 1,0,0\n		@figures.push new Rect cv(130,130), 100,100, 1,1,0\n		@figures.push new Triangle cv(100,100), cv(120,0), cv(190,120), 0,1,0\n		@figures.push new Quad cv(0,160), cv(60,100), cv(100,120), cv(60,200), 0.5,0.5,0.5\n	draw : ->\n		rectMode CENTER\n		textAlign CENTER,CENTER\n		textSize 50\n		bg 0.5\n		sc 0\n		sw 2\n		for figure in @figures\n			fc figure.r,figure.g,figure.b,0.5\n			figure.draw()\n	mousePressed : (mx,my) ->\n		rev = @figures[..]\n		rev.reverse()\n		for figure in rev\n			return if figure.detect mx,my\n\napp = new ClickDetector \"a\"",
  c: {
    app: "reset()"
  },
  e: {
    Triangle: "http://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle"
  }
};

ID_CoffeescriptClock = {
  v: '2017-04-29',
  b: "# LOC:10 bg fc sc range # * + - for in \"\" radians text textSize textAlign",
  a: "bg 1\nfc 0\nsc()\ntextSize 20\ntextAlign CENTER,CENTER\nfor i in range 12\n	v = radians 30*i-90\n	x = 100 + 90 * cos v\n	y = 100 + 90 * sin v\n	text \"Coffeescript\"[i],x,y"
};

ID_ColorCross = {
  v: '2017-04-29',
  b: "# LOC:11 bg sc sw range # for in point\n",
  a: "bg 0.5\nfor k in range 6\n	x = [75,25,75,125,75,75][k]\n	y = [50,50,100,50,0,150][k]\n	for i in range 50\n		r = [i/50,0,i/50,1,i/50,i/50][k]\n		for j in range 50\n			g = [j/50,j/50,1,j/50,0,(50-j)/50][k]\n			b = [0,(50-i)/50,j/50,i/50,(50-j)/50,1][k]\n			sc r,g,b\n			point x+i,y+j"
};

ID_ColorCube = {
  v: '2017-04-29',
  b: "# LOC:33 bg range # for in class extends constructor new @ super ->\n#        quad [] push pop fill stroke if then and * / + - <= return\n\nclass ColorCube extends Application\n	reset       : ->\n		super\n	draw        : ->\n	undo 				: ->\n	mousePressed : (mx,my) ->\napp = new ColorCube",
  a: "class ColorCube extends Application\n	reset : ->\n		super\n		@r = 0\n		@g = 0\n		@b = 0\n		@size = 256\n		@history = []\n	draw : ->\n		bg 0\n		@c = @size / 4\n		for b in range 4\n			for r in range 4\n				for g in range 4\n					fill   @r+r*@c+@c/2, @g+g*@c+@c/2, @b+b*@c+@c/2\n					stroke @r+r*@c+@c/2, @g+g*@c+@c/2, @b+b*@c+@c/2\n					x = r*40-g*10\n					y = g*10+b*50 + 5\n					quad x+40,y+0, x+80,y+0, x+70,y+10, x+30,y+10\n	mousePressed : (mx,my) ->\n		if @size == 4 then return\n		for b in range 4\n			for r in range 4\n				for g in range 4\n					x = r*40-g*10\n					y = g*10+b*50 + 5\n					if x+35 <= mx <= x+75 and y <= my <= y+10\n						@history.push [@r,@g,@b,@size]\n						@size /= 4\n						@r += r * @size\n						@g += g * @size\n						@b += b * @size\n						return\n\n	undo : -> if @history.length > 0 then [@r,@g,@b,@size] = @history.pop()\n\napp = new ColorCube \"a\"",
  c: {
    app: "reset()|undo()"
  },
  e: {
    ColorCube: "https://www.google.se/search?q=color+cube&tbm=isch&tbo=u&source=univ&sa=X&ved=0ahUKEwjo3_Cm3Y7TAhUJb5oKHcFhCKQQsAQIJg&biw=1745&bih=963&dpr=1.1"
  }
};

ID_ColorPair = {
  v: '2017-04-29',
  b: "# LOC:41 fc circle # [] .. push dist length splice _.isEqual colorMode HSB\n#        _.max _.pairs _.sortBy for in class extends constructor new @ super ->\n\nclass ColorPair extends Application\n	reset : ->\n		super\n		@seed = 0\n	draw : ->\n	mousePressed : (mx,my) ->\n	enterName : ->\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\napp = new ColorPair",
  a: "class ColorPair extends Application\n	reset : ->\n		super\n		@radius = 0\n		@seed = 0\n		@level = 0\n		@changeLevel 1\n		@name = \"\"\n		@highScore = {}\n\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\n\n	draw : ->\n		bg 1\n		sw 2\n		sc 1,1,1,0.5\n		colorMode HSB\n		for [x,y,c] in @circles\n			fill color c,100,100,0.5\n			circle x,y,@radius\n\n	mousePressed : (mx,my) ->\n		hitlist = []\n		for [x,y,c],i in @circles\n			if dist(x,y,mx,my) < @radius then hitlist.push i\n		if hitlist.length == 1\n			i = hitlist[0]\n			circle = @circles[i]\n			if @memory == -1\n				@memory = circle[2]\n				@circles.splice i,1\n			else if _.isEqual(@memory, circle[2])\n				@memory = -1\n				@circles.splice i,1\n				if @circles.length == 0\n					@updateHighScore() if @name != \"\"\n					@changeLevel 1\n			else\n				@changeLevel -1\n		else\n			@changeLevel -1\n\n	updateHighScore : ->\n		@highScore[@name] = _.max [@level, @highScore[@name]]\n		@topList = _.pairs @highScore\n		@topList = _.sortBy @topList, ([name,level]) -> -level\n\n	changeLevel : (d) ->\n		@memory = -1\n		@level = constrain @level+d, 1, 20\n		@circles = []\n		@radius = 50\n		for i in range @level\n			@radius *= 0.95\n			c = int i * 360 / @level\n			@circles.push [@randint(200), @randint(200), c]\n			@circles.push [@randint(200), @randint(200), c]\n\n	enterName : -> @name = @readText()\n\napp = new ColorPair \"a\"",
  c: {
    app: "reset()|enterName()"
  },
  e: {
    ColorPair: "https://christernilsson.github.io/ColorPair"
  }
};

ID_Complex = {
  v: '2017-04-29',
  b: "# LOC:80 bg fc sc range # * / + %% [] line circle text textAlign textSize for in if then else return int\n#        {} dist _.isEqual and < != == push pop length constrain class extends constructor new @ super ->\n\nclass Complex extends Application\n	reset : ->\n		super\n	draw : ->\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\n	mousePressed : (mx,my) ->\napp = new Complex",
  a: "class Complex extends Application\n	reset : ->\n		super\n		@RADIUS = 25\n		@buttons = [[30,130,'m'],[70,170,'*i'],[130,170,'*2'],[170,130,'+1'],[30,30,'undo'], [170,30,'new']]\n		@seed = 0\n		@level = 1\n		@createGame()\n	randint : (n) -> int n * fraction 10000 * Math.sin @seed++\n	gr : ->\n		sc 1,1,1,0.5\n		for i in range 21\n			line 0, 10 * i, 200, 10 * i\n			line 10 * i, 0, 10 * i, 200\n		sc 1,1,1\n		line 100,0, 100,200\n		line 0,100, 200,100\n	draw : ->\n		@buttons[4][2] = @level - @history.length\n		bg 0\n		@gr()\n		textAlign CENTER,CENTER\n		textSize 25\n		sc()\n		fc 1,0,0\n		circle 100+10*@b[0], 100-10*@b[1], 5\n		fc 0,1,0\n		circle 100+10*@a[0], 100-10*@a[1], 4\n		for [x,y,txt],i in @buttons\n			fc 1,1,0,0.4\n			circle x,y,@RADIUS\n			fc 1,1,0\n			text txt,x,y\n	newGame : ->\n		if @level >= @history.length and _.isEqual(@a,@b) then d=1 else d=-1\n		@level = constrain @level+d,1,16\n		@createGame()\n	createGame : ->\n		@history = []\n		@a = [-10 + @randint(20), -10 + @randint(20)]\n		q1 = [@a]\n		q2 = []\n		visited = {}\n		visited[@a] = true\n		expand = (n) ->\n			if visited[n] then return\n			if n[0]*n[0] + n[1]*n[1] > 1000 then return\n			visited[n] = true\n			q2.push n\n		for level in range @level\n			for [x,y] in q1\n				expand [y,x]\n				expand [-y,x]\n				expand [2*x,2*y]\n				expand [x+1,y]\n			q1 = q2\n			q2 = []\n		@b = @selectTarget q1\n	selectTarget : (lst) -> # within 21x21 window, if possible\n		bs = ([x,y] for [x,y] in lst when -10 <= x <= 10 and -10 <= y <= 10)\n		return bs[@randint(bs.length)] if bs.length > 0\n		_.min lst, ([x,y]) -> dist 0,0,x,y\n	undo : ->\n		if @history.length == 0 then return\n		@a = @history.pop()\n	mousePressed : (mx,my) ->\n		index = -1\n		for [x,y,txt],i in @buttons\n			if dist(mx,my,x,y) < @RADIUS then index = i\n		[x,y] = @a\n		a = []\n		if index == 0 then a = [y,x]\n		if index == 1 then a = [-y,x]\n		if index == 2 then a = [2*x,2*y]\n		if index == 3 then a = [x+1,y]\n		if index == 4 then @undo()\n		if index == 5 then @newGame()\n		if a.length != 0\n			@history.push @a\n			@a = a\n\napp = new Complex \"a\"\n",
  c: {
    app: "reset()"
  },
  e: {
    "Komplexa tal": "http://www.matteboken.se/lektioner/matte-4/komplexa-tal/rakna-med-komplexa-tal"
  }
};

ID_Connect4 = {
  v: '2017-04-29',
  b: "# LOC:33 % bg fc sc sw circle range # text textAlign textSize for in\n#        push pop class extends constructor new @ super ->\n\nclass Connect4 extends Application\n	reset : ->\n		super\n	draw  : ->\n	undo  : ->\n	mousePressed : (mx,my) ->\napp = new Connect4",
  a: "class Connect4 extends Application\n	reset : ->\n		super\n		@SIZE = 27\n		@list = ([] for i in range 7)\n		@moves = []\n	draw : ->\n		bg 0\n		textAlign CENTER,CENTER\n		textSize @SIZE/2\n		fc()\n		sc 0.1,0.3,1\n		sw 0.2 * @SIZE\n		for i in range 7\n			for j in range 6\n				circle 100-@SIZE*3+@SIZE*i, 180-@SIZE*j, @SIZE/2\n		for column,i in @list\n			for nr,j in column\n				fc 1,nr%2,0\n				sw 1\n				circle 100-@SIZE*3+@SIZE*i, 180-@SIZE*j, @SIZE*0.4\n				fc 0\n				sc()\n				text nr, 100-@SIZE*3+@SIZE*i, 180-@SIZE*j\n		sc()\n		fc 1,(@moves.length+1)%2,0\n		circle 100,15,10\n	mousePressed : (mx,my) ->\n		nr = int (mx-(200-7*@SIZE)/2)/@SIZE\n		if 0 <= nr <= 6\n			@moves.push nr\n			@list[nr].push @moves.length\n	undo : -> if @moves.length > 0 then @list[@moves.pop()].pop()\n\napp = new Connect4 \"a\"",
  c: {
    app: "reset()|undo()"
  },
  e: {
    Wikipedia: "https://en.wikipedia.org/wiki/Connect_Four"
  }
};

ID_CornerPoints = {
  v: '2017-04-29',
  b: "# LOC:9 sc sw # point\n\nsw\nsc\npoint\n",
  a: "sw 10\nsc 1,0,0\npoint 0,0\nsc 0,1,0\npoint 200,0\nsc 1,1,0\npoint 0,200\nsc 0\npoint 200,200",
  e: {
    Matteboken: "http://www.matteboken.se/lektioner/matte-1/funktioner/koordinatsystem"
  }
};

ID_CornerPoints3 = {
  v: '2017-04-29',
  b: "# LOC:17 sc sw # point\n",
  a: "sw 10\nsc 1,0,0\npoint 20,0\npoint 20,20\npoint 0,20\n\nsc 0,1,0\npoint 180,0\npoint 180,20\npoint 200,20\n\nsc 1,1,0\npoint 20,180\npoint 20,200\npoint 0,180\n\nsc 1\npoint 180,180\npoint 180,200\npoint 200,180",
  e: {
    Matteboken: "http://www.matteboken.se/lektioner/matte-1/funktioner/koordinatsystem"
  }
};

ID_CornerPoints7 = {
  v: '2017-04-29',
  b: "# LOC:17 sc sw # point\n",
  a: "sw 10\nsc 1,0,0\npoint 30,0\npoint 30,10\npoint 30,20\npoint 30,30\npoint 10,30\npoint 20,30\npoint 0,30\n\nsc 0,1,0\npoint 170,200\npoint 170,190\npoint 170,180\npoint 170,170\npoint 190,170\npoint 180,170\npoint 200,170",
  e: {
    Matteboken: "http://www.matteboken.se/lektioner/matte-1/funktioner/koordinatsystem"
  }
};

ID_Counter = {
  v: '2017-04-29',
  b: "# LOC:12 bg fc sc # text textAlign textSize + - class extends constructor new @ super ->\n# Klicka på reset() om du får ett felmeddelande!\n\nclass Counter extends Application\n	reset : ->\n		super\n	draw  : ->\n	up    : ->\n	down  : ->\n	mousePressed : (mx,my) -> print \"mousePressed\",mx,my\napp = new Counter",
  a: "class Counter extends Application\n	reset : ->\n		super\n		@counter = 0\n	up : -> @counter += 1\n	down : -> @counter -= 1\n	draw : ->\n		bg 0.5\n		fc 1,1,0\n		sc()\n		textAlign CENTER,CENTER\n		textSize 100\n		text @counter,100,100\n	mousePressed : (mx,my) -> if my < 100 then @counter += 1 else @counter -= 1\n\napp = new Counter \"a\"",
  c: {
    app: "reset()|up()|down()"
  }
};

ID_Cross = {
  v: '2017-04-29',
  b: "# LOC:4 fc # rect\n",
  a: "fc 1,0,0\nsc()\nrect 85,70, 70,10\nrect 115,40, 10,100"
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQy5qcyIsInNvdXJjZVJvb3QiOiIuLlxcLi4iLCJzb3VyY2VzIjpbImNvZmZlZVxcZGF0YVxcQy5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLElBQUE7O0FBQUEsUUFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUUsd0VBREY7RUFFQSxDQUFBLEVBQUUsOElBRkY7OztBQWVELGFBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFFLDBDQURGO0VBRUEsQ0FBQSxFQUFFLDRHQUZGOzs7QUFZRCxZQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSxzZkFERjtFQWVBLENBQUEsRUFBRSx5NkNBZkY7RUF5RUEsQ0FBQSxFQUNDO0lBQUEsR0FBQSxFQUFNLFNBQU47R0ExRUQ7OztBQTRFRCxXQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSw0Q0FERjtFQUVBLENBQUEsRUFBRSxvRUFGRjs7O0FBVUQsZ0JBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFFLG1iQURGO0VBaUJBLENBQUEsRUFBRSwyckVBakJGO0VBeUZBLENBQUEsRUFDQztJQUFBLEdBQUEsRUFBTSxTQUFOO0dBMUZEO0VBMkZBLENBQUEsRUFDQztJQUFBLFFBQUEsRUFBVyw0RkFBWDtHQTVGRDs7O0FBOEZELG9CQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSw2RUFERjtFQUlBLENBQUEsRUFBRSw4S0FKRjs7O0FBaUJELGFBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFFLDBDQURGO0VBRUEsQ0FBQSxFQUFFLDJSQUZGOzs7QUFnQkQsWUFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUcsaVNBREg7RUFhQSxDQUFBLEVBQUcsazNCQWJIO0VBb0RBLENBQUEsRUFDQztJQUFBLEdBQUEsRUFBTSxnQkFBTjtHQXJERDtFQXNEQSxDQUFBLEVBQ0M7SUFBQSxTQUFBLEVBQVksZ0pBQVo7R0F2REQ7OztBQXlERCxZQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRyxrWEFESDtFQWVBLENBQUEsRUFBRSxrM0NBZkY7RUE4RUEsQ0FBQSxFQUNDO0lBQUEsR0FBQSxFQUFNLHFCQUFOO0dBL0VEO0VBZ0ZBLENBQUEsRUFDQztJQUFBLFNBQUEsRUFBWSw2Q0FBWjtHQWpGRDs7O0FBbUZELFVBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFFLHdZQURGO0VBYUEsQ0FBQSxFQUFFLGdqRUFiRjtFQWtHQSxDQUFBLEVBQ0M7SUFBQSxHQUFBLEVBQU0sU0FBTjtHQW5HRDtFQW9HQSxDQUFBLEVBQ0M7SUFBQSxjQUFBLEVBQWlCLGdGQUFqQjtHQXJHRDs7O0FBdUdELFdBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFFLHdRQURGO0VBYUEsQ0FBQSxFQUFFLDB5QkFiRjtFQWtEQSxDQUFBLEVBQ0M7SUFBQSxHQUFBLEVBQU0sZ0JBQU47R0FuREQ7RUFvREEsQ0FBQSxFQUNDO0lBQUEsU0FBQSxFQUFZLDRDQUFaO0dBckREOzs7QUF1REQsZUFBQSxHQUNDO0VBQUEsQ0FBQSxFQUFFLFlBQUY7RUFDQSxDQUFBLEVBQUcsMENBREg7RUFTQSxDQUFBLEVBQUcsK0ZBVEg7RUFvQkEsQ0FBQSxFQUNDO0lBQUEsVUFBQSxFQUFhLHVFQUFiO0dBckJEOzs7QUF1QkQsZ0JBQUEsR0FDQztFQUFBLENBQUEsRUFBRSxZQUFGO0VBQ0EsQ0FBQSxFQUFHLDBCQURIO0VBRUEsQ0FBQSxFQUFHLHFOQUZIO0VBd0JBLENBQUEsRUFDQztJQUFBLFVBQUEsRUFBYSx1RUFBYjtHQXpCRDs7O0FBMkJELGdCQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRywwQkFESDtFQUVBLENBQUEsRUFBRywrTkFGSDtFQXNCQSxDQUFBLEVBQ0M7SUFBQSxVQUFBLEVBQWEsdUVBQWI7R0F2QkQ7OztBQXlCRCxVQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSwwVEFERjtFQWNBLENBQUEsRUFBRSxrVkFkRjtFQWdDQSxDQUFBLEVBQ0M7SUFBQSxHQUFBLEVBQU0scUJBQU47R0FqQ0Q7OztBQW1DRCxRQUFBLEdBQ0M7RUFBQSxDQUFBLEVBQUUsWUFBRjtFQUNBLENBQUEsRUFBRSxxQkFERjtFQUVBLENBQUEsRUFBRSx3REFGRiIsInNvdXJjZXNDb250ZW50IjpbIklEX0NhcmRzID1cblx0djonMjAxNy0wNC0yOSdcblx0YjpcIiMgTE9DOjEwIGZjIHNjIGNpcmNsZSByYW5nZSByZCAjIHJlY3QgcmVjdE1vZGUgZm9yIGluIGxlcnAgdHJhbnNsYXRlXFxuXCJcblx0YTpcIlwiXCJcbnJlY3RNb2RlIENFTlRFUlxuc2MgMVxudHJhbnNsYXRlIDEwMCwxMDBcbmZvciBpIGluIHJhbmdlIDE4LC0xLC0xXG5cdHIgPSAxLjAqaS8xOFxuXHRmYyByLDAsMFxuXHR3ID0gNzArNSppXG5cdGggPSA3MCs1Kmlcblx0cmVjdCAwLDAsIHcsaFxuXHRyZCA1XG5cIlwiXCJcblxuSURfQ2hlc3NCb2FyZCA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCIjIExPQzo3IGJnIGZjIHJhbmdlICMgZm9yIGluIGxlcnAgcmVjdFxcblwiXG5cdGE6XCJcIlwiXG5iZyAwLjVcbmZvciBpIGluIHJhbmdlIDhcblx0Zm9yIGogaW4gcmFuZ2UgOFxuXHRcdGZjIChpK2opJTJcblx0XHR4ID0gMjArMjAqaVxuXHRcdHkgPSAyMCsyMCpqXG5cdFx0cmVjdCB4LHksIDIwLDIwXG5cIlwiXCJcblxuSURfQ2hlc3NHYW1lID1cblx0djonMjAxNy0wNC0yOSdcblx0YjpcIlwiXCJcbiMgTE9DOjUzIGJnIGZjIHNjIHN3IHJhbmdlIGNpcmNsZSAjIHJlY3RNb2RlIGNsYXNzIGNvbnN0cnVjdG9yIHN1cGVyIGV4dGVuZHMgbmV3IEBcbiMgICAgICAgIHJlY3QgaWYgdGhlbiBlbHNlIHRleHQgdGV4dFNpemUgdGV4dEFsaWduIGZvciBpbiBzcGxpdCBsZW5ndGggaW5kZXhPZlxuIyAgICAgICAgXCJcIiB0b1VwcGVyQ2FzZSBfLmlzRXF1YWwgJSArIC0gKiAvIDw9ID09IFtdIHB1c2ggcG9wIGxlbmd0aCBhbmQgbm90IHN1YnN0clxuIyBPQlMhICAgUm9ja2FkLCBlbiBwYXNzYW50IHNhbXQgYm9uZGVmw7ZydmFuZGxpbmcgaGFudGVyYXMgZWouXG4jICAgICAgICBGbHl0dGEgcGrDpHNlcm5hIG1lZCBtdXNlbi4gS2xpY2sgdXRhbmbDtnIgYnLDpGRldCBpbm5lYsOkciB1bmRvLlxuXG5jbGFzcyBDaGVzcyBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRkcmF3ICA6IC0+XG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT5cbmFwcCA9IG5ldyBDaGVzc1xuXCJcIlwiXG5cdGE6XCJcIlwiXG5jbGFzcyBDaGVzcyBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRcdEBTSVpFID0gMjJcblx0XHRAWCA9IDEwMFxuXHRcdEBZID0gMTAwXG5cdFx0QGJvYXJkID0gWydSTkJRS0JOUicsJ1BQUFBQUFBQJywnLi4uLi4uLi4nLCcuLi4uLi4uLicsJy4uLi4uLi4uJywnLi4uLi4uLi4nLCdwcHBwcHBwcCcsJ3JuYnFrYm5yJ11cblx0XHRAaGlzdG9yeSA9IFtdXG5cdFx0QG1lbW9yeSA9IDBcblx0ZHJhdyA6IC0+XG5cdFx0YmcgMC41XG5cdFx0dGV4dFNpemUgMC45ICogQFNJWkVcblx0XHR0ZXh0QWxpZ24gQ0VOVEVSLENFTlRFUlxuXHRcdHJlY3RNb2RlIENFTlRFUlxuXHRcdHNjKClcblx0XHRmb3IgaSBpbiByYW5nZSA4XG5cdFx0XHRmb3IgaiBpbiByYW5nZSA4XG5cdFx0XHRcdGlmIChpK2opJTIgPT0gMCB0aGVuIGZjIDAuNiBlbHNlIGZjIDAuOFxuXHRcdFx0XHR4ID0gQFgtMy41KkBTSVpFK0BTSVpFKmlcblx0XHRcdFx0eSA9IEBZLTMuNSpAU0laRStAU0laRSooNy1qKVxuXHRcdFx0XHRpZiBfLmlzRXF1YWwgQG1lbW9yeSxbaSxqXSB0aGVuIGZjIDAsMSwwXG5cdFx0XHRcdHJlY3QgeCx5LCBAU0laRSwgQFNJWkVcblx0XHRcdFx0cGllY2UgPSBAYm9hcmRbal1baV1cblx0XHRcdFx0aWYgcGllY2UgaW4gXCJSTkJRS1BcIiB0aGVuIGZjIDAuOTUgZWxzZSBmYyAwXG5cdFx0XHRcdGlmIHBpZWNlICE9ICcuJ1xuXHRcdFx0XHRcdGlmIHBpZWNlIGluIFwicFBcIiB0aGVuIGNpcmNsZSB4LHksNSBlbHNlIHRleHQgcGllY2UudG9VcHBlckNhc2UoKSx4LHlcblx0c2V0Q2hhckF0IDogKGksaixjaHIpIC0+XG4gICAgQGJvYXJkW2pdID0gQGJvYXJkW2pdLnN1YnN0cigwLGkpICsgY2hyICsgQGJvYXJkW2pdLnN1YnN0cihpKzEpXG5cdG1vdmUgOiAoYSxiKSAtPlxuXHRcdFtpMSxqMV0gPSBhXG5cdFx0W2kyLGoyXSA9IGJcblx0XHR0YWtlbiA9IEBib2FyZFtqMl1baTJdXG5cdFx0QHNldENoYXJBdCBpMixqMiwgQGJvYXJkW2oxXVtpMV1cblx0XHRAc2V0Q2hhckF0IGkxLGoxLCcgJ1xuXHRcdEBoaXN0b3J5LnB1c2ggW2EsYix0YWtlbl1cblx0dW5kbyA6ICgpIC0+XG5cdFx0aWYgQGhpc3RvcnkubGVuZ3RoID09IDAgdGhlbiByZXR1cm5cblx0XHRbYSxiLHRha2VuXSA9IEBoaXN0b3J5LnBvcCgpXG5cdFx0W2kxLGoxXSA9IGFcblx0XHRbaTIsajJdID0gYlxuXHRcdEBzZXRDaGFyQXQgaTEsajEsIEBib2FyZFtqMl1baTJdXG5cdFx0QHNldENoYXJBdCBpMixqMiwgdGFrZW5cblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuXHRcdGkgPSBpbnQgKG14LTIwKS8yMFxuXHRcdGogPSA3IC0gaW50IChteS0yMCkvMjBcblx0XHRpZiAwIDw9IGkgPD0gNyBhbmQgMCA8PSBqIDw9IDdcblx0XHRcdGlmIEBtZW1vcnkgPT0gMFxuXHRcdFx0XHRAbWVtb3J5ID0gW2ksal1cblx0XHRcdGVsc2Vcblx0XHRcdFx0aWYgbm90IF8uaXNFcXVhbCBAbWVtb3J5LFtpLGpdIHRoZW4gQG1vdmUgQG1lbW9yeSxbaSxqXVxuXHRcdFx0XHRAbWVtb3J5ID0gMFxuXHRcdGVsc2Vcblx0XHRcdEB1bmRvKClcblxuYXBwID0gbmV3IENoZXNzIFwiYVwiXG5cblwiXCJcIlxuXHRjOlxuXHRcdGFwcCA6IFwicmVzZXQoKVwiXG5cbklEX0NoZXNzUm93ID1cblx0djonMjAxNy0wNC0yOSdcblx0YjpcIiMgTE9DOjUgYmcgZmMgcmFuZ2UgIyAlIGZvciBpbiBsZXJwIHJlY3RcXG5cIlxuXHRhOlwiXCJcIlxuYmcgMC41XG5mb3IgaSBpbiByYW5nZSA4XG5cdGZjIGklMlxuXHR4ID0gMjArMjAqaVxuXHRyZWN0IHgsMjAsIDIwLDIwXG5cIlwiXCJcblxuSURfQ2xpY2tEZXRlY3RvciA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCJcIlwiXG4jIExPQzo2MiBiZyBzYyBmYyByYW5nZSBjaXJjbGUgIyBxdWFkIHJlY3QgdHJpYW5nbGUgY2xhc3MgZXh0ZW5kcyBjb25zdHJ1Y3RvciBuZXcgQCBzdXBlciAtPlxuIyAgICAgICAgb3IgYW5kID09IGRpc3QgcmV2ZXJzZSBpZiB0aGVuIDwgYW5kICogLyArIC0gKysgdGV4dCB0ZXh0QWxpZ24gdGV4dFNpemUgcmVjdE1vZGVcblxuY2xhc3MgVmVjdG9yXG5cdGNvbnN0cnVjdG9yIDogKEB4LEB5KSAtPlxuXHRhZGQgOiAoYikgLT4gbmV3IFZlY3RvciBAeCtiLngsQHkrYi55XG5cdGRpdiA6IChuKSAtPiBuZXcgVmVjdG9yIEB4L24sQHkvblxuXG5jbGFzcyBDbGlja0RldGVjdG9yIGV4dGVuZHMgQXBwbGljYXRpb25cblx0cmVzZXQgOiAtPlxuXHRcdHN1cGVyXG5cdGRyYXcgIDogLT5cblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuYXBwID0gbmV3IENsaWNrRGV0ZWN0b3JcblwiXCJcIlxuXHRhOlwiXCJcIlxuY2xhc3MgVmVjdG9yICMgcGdhIGF0dCBwNS5WZWN0b3Iga3JvY2thciBtZWQgbWluIHNlcmlhbGlzZXJpbmdcblx0Y29uc3RydWN0b3IgOiAoQHgsQHkpIC0+XG5cdGFkZCA6IChiKSAtPiBjdiBAeCtiLngsQHkrYi55XG5cdGRpdiA6IChuKSAtPiBjdiBAeC9uLEB5L25cbmN2ID0gKHgseSkgLT4gbmV3IFZlY3RvciB4LHlcblxuY2xhc3MgRmlndXJlXG5cdGNvbnN0cnVjdG9yIDogKHBjKSAtPlxuXHRcdEBwYyA9IGN2KGludChwYy54KSxpbnQocGMueSkpXG5cdFx0QGNvdW50ZXIgPSAwXG5cdGRyYXcgOiAtPiB0ZXh0IEBjb3VudGVyLEBwYy54LEBwYy55XG5cdGRldGVjdCA6IChib29sKSAtPlxuXHRcdGlmIGJvb2wgdGhlbiBAY291bnRlcisrXG5cdFx0Ym9vbFxuXG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBGaWd1cmVcblx0Y29uc3RydWN0b3IgOiAoQHAsQHJhZGl1cyxAcixAZyxAYikgLT4gc3VwZXIgQHBcblx0ZGV0ZWN0IDogKG14LG15KSAtPiBzdXBlciBAcmFkaXVzID4gZGlzdCBAcC54LEBwLnksbXgsbXlcblx0ZHJhdyA6IC0+IHN1cGVyIGNpcmNsZSBAcC54LEBwLnksIEByYWRpdXNcblxuY2xhc3MgUmVjdCBleHRlbmRzIEZpZ3VyZVxuXHRjb25zdHJ1Y3RvciA6IChAcCxAdyxAaCxAcixAZyxAYikgLT4gc3VwZXIgQHBcblx0ZGV0ZWN0IDogKG14LG15KSAtPiBzdXBlciBAcC54LUB3LzIgPCBteCA8IEBwLngrQHcvMiBhbmQgQHAueS1AaC8yIDwgbXkgPCBAcC55K0BoLzJcblx0ZHJhdyA6IC0+IHN1cGVyIHJlY3QgQHAueCxAcC55LEB3LEBoXG5cbmNsYXNzIFRyaWFuZ2xlIGV4dGVuZHMgRmlndXJlXG5cdGNvbnN0cnVjdG9yIDogKEB2MSxAdjIsQHYzLEByPTAsQGc9MCxAYj0wKSAtPiBzdXBlciBAdjEuYWRkKEB2MikuYWRkKEB2MykuZGl2KDMpXG5cdGRldGVjdCA6IChteCxteSkgLT5cblx0XHRwdCA9IGN2IG14LG15XG5cdFx0c2lnbiA9IChwMSxwMixwMykgLT4gKHAxLnggLSBwMy54KSAqIChwMi55IC0gcDMueSkgLSAocDIueCAtIHAzLngpICogKHAxLnkgLSBwMy55KVxuXHRcdGIxID0gMCA+IHNpZ24gcHQsIEB2MSwgQHYyXG5cdFx0YjIgPSAwID4gc2lnbiBwdCwgQHYyLCBAdjNcblx0XHRiMyA9IDAgPiBzaWduIHB0LCBAdjMsIEB2MVxuXHRcdHN1cGVyIGIxID09IGIyIGFuZCBiMiA9PSBiM1xuXHRkcmF3IDogLT4gc3VwZXIgdHJpYW5nbGUgQHYxLngsQHYxLnksIEB2Mi54LEB2Mi55LCBAdjMueCxAdjMueVxuXG5jbGFzcyBRdWFkIGV4dGVuZHMgRmlndXJlXG5cdGNvbnN0cnVjdG9yIDogKEB2MSxAdjIsQHYzLEB2NCwgQHIsQGcsQGIpIC0+IHN1cGVyIEB2MS5hZGQoQHYyKS5hZGQoQHYzKS5hZGQoQHY0KS5kaXYoNClcblx0ZGV0ZWN0IDogKG14LG15KSAtPlxuXHRcdHQxID0gbmV3IFRyaWFuZ2xlIEB2MSxAdjIsQHYzXG5cdFx0dDIgPSBuZXcgVHJpYW5nbGUgQHYxLEB2MyxAdjRcblx0XHRzdXBlciB0MS5kZXRlY3QobXgsbXkpIG9yIHQyLmRldGVjdChteCxteSlcblx0ZHJhdyA6IC0+IHN1cGVyIHF1YWQgQHYxLngsQHYxLnksIEB2Mi54LEB2Mi55LCBAdjMueCxAdjMueSwgQHY0LngsQHY0LnlcblxuY2xhc3MgQ2xpY2tEZXRlY3RvciBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdGNsYXNzZXMgOiAtPiBbVmVjdG9yLENpcmNsZSxSZWN0LFRyaWFuZ2xlLFF1YWRdXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRcdEBmaWd1cmVzID0gW11cblx0XHRAZmlndXJlcy5wdXNoIG5ldyBDaXJjbGUgY3YoNzAsNzApLCA1MCwgMSwwLDBcblx0XHRAZmlndXJlcy5wdXNoIG5ldyBSZWN0IGN2KDEzMCwxMzApLCAxMDAsMTAwLCAxLDEsMFxuXHRcdEBmaWd1cmVzLnB1c2ggbmV3IFRyaWFuZ2xlIGN2KDEwMCwxMDApLCBjdigxMjAsMCksIGN2KDE5MCwxMjApLCAwLDEsMFxuXHRcdEBmaWd1cmVzLnB1c2ggbmV3IFF1YWQgY3YoMCwxNjApLCBjdig2MCwxMDApLCBjdigxMDAsMTIwKSwgY3YoNjAsMjAwKSwgMC41LDAuNSwwLjVcblx0ZHJhdyA6IC0+XG5cdFx0cmVjdE1vZGUgQ0VOVEVSXG5cdFx0dGV4dEFsaWduIENFTlRFUixDRU5URVJcblx0XHR0ZXh0U2l6ZSA1MFxuXHRcdGJnIDAuNVxuXHRcdHNjIDBcblx0XHRzdyAyXG5cdFx0Zm9yIGZpZ3VyZSBpbiBAZmlndXJlc1xuXHRcdFx0ZmMgZmlndXJlLnIsZmlndXJlLmcsZmlndXJlLmIsMC41XG5cdFx0XHRmaWd1cmUuZHJhdygpXG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT5cblx0XHRyZXYgPSBAZmlndXJlc1suLl1cblx0XHRyZXYucmV2ZXJzZSgpXG5cdFx0Zm9yIGZpZ3VyZSBpbiByZXZcblx0XHRcdHJldHVybiBpZiBmaWd1cmUuZGV0ZWN0IG14LG15XG5cbmFwcCA9IG5ldyBDbGlja0RldGVjdG9yIFwiYVwiXG5cIlwiXCJcblx0Yzpcblx0XHRhcHAgOiBcInJlc2V0KClcIlxuXHRlOlxuXHRcdFRyaWFuZ2xlIDogXCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwNDk1ODIvaG93LXRvLWRldGVybWluZS1pZi1hLXBvaW50LWlzLWluLWEtMmQtdHJpYW5nbGVcIlxuXG5JRF9Db2ZmZWVzY3JpcHRDbG9jayA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCJcIlwiXG4jIExPQzoxMCBiZyBmYyBzYyByYW5nZSAjICogKyAtIGZvciBpbiBcIlwiIHJhZGlhbnMgdGV4dCB0ZXh0U2l6ZSB0ZXh0QWxpZ25cblwiXCJcIlxuXHRhOlwiXCJcIlxuYmcgMVxuZmMgMFxuc2MoKVxudGV4dFNpemUgMjBcbnRleHRBbGlnbiBDRU5URVIsQ0VOVEVSXG5mb3IgaSBpbiByYW5nZSAxMlxuXHR2ID0gcmFkaWFucyAzMCppLTkwXG5cdHggPSAxMDAgKyA5MCAqIGNvcyB2XG5cdHkgPSAxMDAgKyA5MCAqIHNpbiB2XG5cdHRleHQgXCJDb2ZmZWVzY3JpcHRcIltpXSx4LHlcblwiXCJcIlxuXG5JRF9Db2xvckNyb3NzID1cblx0djonMjAxNy0wNC0yOSdcblx0YjpcIiMgTE9DOjExIGJnIHNjIHN3IHJhbmdlICMgZm9yIGluIHBvaW50XFxuXCJcblx0YTpcIlwiXCJcbmJnIDAuNVxuZm9yIGsgaW4gcmFuZ2UgNlxuXHR4ID0gWzc1LDI1LDc1LDEyNSw3NSw3NV1ba11cblx0eSA9IFs1MCw1MCwxMDAsNTAsMCwxNTBdW2tdXG5cdGZvciBpIGluIHJhbmdlIDUwXG5cdFx0ciA9IFtpLzUwLDAsaS81MCwxLGkvNTAsaS81MF1ba11cblx0XHRmb3IgaiBpbiByYW5nZSA1MFxuXHRcdFx0ZyA9IFtqLzUwLGovNTAsMSxqLzUwLDAsKDUwLWopLzUwXVtrXVxuXHRcdFx0YiA9IFswLCg1MC1pKS81MCxqLzUwLGkvNTAsKDUwLWopLzUwLDFdW2tdXG5cdFx0XHRzYyByLGcsYlxuXHRcdFx0cG9pbnQgeCtpLHkralxuXCJcIlwiXG5cbklEX0NvbG9yQ3ViZSA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6IFwiXCJcIlxuIyBMT0M6MzMgYmcgcmFuZ2UgIyBmb3IgaW4gY2xhc3MgZXh0ZW5kcyBjb25zdHJ1Y3RvciBuZXcgQCBzdXBlciAtPlxuIyAgICAgICAgcXVhZCBbXSBwdXNoIHBvcCBmaWxsIHN0cm9rZSBpZiB0aGVuIGFuZCAqIC8gKyAtIDw9IHJldHVyblxuXG5jbGFzcyBDb2xvckN1YmUgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCAgICAgICA6IC0+XG5cdFx0c3VwZXJcblx0ZHJhdyAgICAgICAgOiAtPlxuXHR1bmRvIFx0XHRcdFx0OiAtPlxuXHRtb3VzZVByZXNzZWQgOiAobXgsbXkpIC0+XG5hcHAgPSBuZXcgQ29sb3JDdWJlXG5cIlwiXCJcblx0YTogXCJcIlwiXG5jbGFzcyBDb2xvckN1YmUgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0XHRAciA9IDBcblx0XHRAZyA9IDBcblx0XHRAYiA9IDBcblx0XHRAc2l6ZSA9IDI1NlxuXHRcdEBoaXN0b3J5ID0gW11cblx0ZHJhdyA6IC0+XG5cdFx0YmcgMFxuXHRcdEBjID0gQHNpemUgLyA0XG5cdFx0Zm9yIGIgaW4gcmFuZ2UgNFxuXHRcdFx0Zm9yIHIgaW4gcmFuZ2UgNFxuXHRcdFx0XHRmb3IgZyBpbiByYW5nZSA0XG5cdFx0XHRcdFx0ZmlsbCAgIEByK3IqQGMrQGMvMiwgQGcrZypAYytAYy8yLCBAYitiKkBjK0BjLzJcblx0XHRcdFx0XHRzdHJva2UgQHIrcipAYytAYy8yLCBAZytnKkBjK0BjLzIsIEBiK2IqQGMrQGMvMlxuXHRcdFx0XHRcdHggPSByKjQwLWcqMTBcblx0XHRcdFx0XHR5ID0gZyoxMCtiKjUwICsgNVxuXHRcdFx0XHRcdHF1YWQgeCs0MCx5KzAsIHgrODAseSswLCB4KzcwLHkrMTAsIHgrMzAseSsxMFxuXHRtb3VzZVByZXNzZWQgOiAobXgsbXkpIC0+XG5cdFx0aWYgQHNpemUgPT0gNCB0aGVuIHJldHVyblxuXHRcdGZvciBiIGluIHJhbmdlIDRcblx0XHRcdGZvciByIGluIHJhbmdlIDRcblx0XHRcdFx0Zm9yIGcgaW4gcmFuZ2UgNFxuXHRcdFx0XHRcdHggPSByKjQwLWcqMTBcblx0XHRcdFx0XHR5ID0gZyoxMCtiKjUwICsgNVxuXHRcdFx0XHRcdGlmIHgrMzUgPD0gbXggPD0geCs3NSBhbmQgeSA8PSBteSA8PSB5KzEwXG5cdFx0XHRcdFx0XHRAaGlzdG9yeS5wdXNoIFtAcixAZyxAYixAc2l6ZV1cblx0XHRcdFx0XHRcdEBzaXplIC89IDRcblx0XHRcdFx0XHRcdEByICs9IHIgKiBAc2l6ZVxuXHRcdFx0XHRcdFx0QGcgKz0gZyAqIEBzaXplXG5cdFx0XHRcdFx0XHRAYiArPSBiICogQHNpemVcblx0XHRcdFx0XHRcdHJldHVyblxuXG5cdHVuZG8gOiAtPiBpZiBAaGlzdG9yeS5sZW5ndGggPiAwIHRoZW4gW0ByLEBnLEBiLEBzaXplXSA9IEBoaXN0b3J5LnBvcCgpXG5cbmFwcCA9IG5ldyBDb2xvckN1YmUgXCJhXCJcblwiXCJcIlxuXHRjOlxuXHRcdGFwcCA6IFwicmVzZXQoKXx1bmRvKClcIlxuXHRlOlxuXHRcdENvbG9yQ3ViZSA6IFwiaHR0cHM6Ly93d3cuZ29vZ2xlLnNlL3NlYXJjaD9xPWNvbG9yK2N1YmUmdGJtPWlzY2gmdGJvPXUmc291cmNlPXVuaXYmc2E9WCZ2ZWQ9MGFoVUtFd2pvM19DbTNZN1RBaFVKYjVvS0hjRmhDS1FRc0FRSUpnJmJpdz0xNzQ1JmJpaD05NjMmZHByPTEuMVwiXG5cbklEX0NvbG9yUGFpciA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6IFwiXCJcIlxuIyBMT0M6NDEgZmMgY2lyY2xlICMgW10gLi4gcHVzaCBkaXN0IGxlbmd0aCBzcGxpY2UgXy5pc0VxdWFsIGNvbG9yTW9kZSBIU0JcbiMgICAgICAgIF8ubWF4IF8ucGFpcnMgXy5zb3J0QnkgZm9yIGluIGNsYXNzIGV4dGVuZHMgY29uc3RydWN0b3IgbmV3IEAgc3VwZXIgLT5cblxuY2xhc3MgQ29sb3JQYWlyIGV4dGVuZHMgQXBwbGljYXRpb25cblx0cmVzZXQgOiAtPlxuXHRcdHN1cGVyXG5cdFx0QHNlZWQgPSAwXG5cdGRyYXcgOiAtPlxuXHRtb3VzZVByZXNzZWQgOiAobXgsbXkpIC0+XG5cdGVudGVyTmFtZSA6IC0+XG5cdHJhbmRpbnQgOiAobikgLT4gaW50IG4gKiBmcmFjdGlvbiAxMDAwMCAqIE1hdGguc2luIEBzZWVkKytcbmFwcCA9IG5ldyBDb2xvclBhaXJcblwiXCJcIlxuXHRhOlwiXCJcIlxuY2xhc3MgQ29sb3JQYWlyIGV4dGVuZHMgQXBwbGljYXRpb25cblx0cmVzZXQgOiAtPlxuXHRcdHN1cGVyXG5cdFx0QHJhZGl1cyA9IDBcblx0XHRAc2VlZCA9IDBcblx0XHRAbGV2ZWwgPSAwXG5cdFx0QGNoYW5nZUxldmVsIDFcblx0XHRAbmFtZSA9IFwiXCJcblx0XHRAaGlnaFNjb3JlID0ge31cblxuXHRyYW5kaW50IDogKG4pIC0+IGludCBuICogZnJhY3Rpb24gMTAwMDAgKiBNYXRoLnNpbiBAc2VlZCsrXG5cblx0ZHJhdyA6IC0+XG5cdFx0YmcgMVxuXHRcdHN3IDJcblx0XHRzYyAxLDEsMSwwLjVcblx0XHRjb2xvck1vZGUgSFNCXG5cdFx0Zm9yIFt4LHksY10gaW4gQGNpcmNsZXNcblx0XHRcdGZpbGwgY29sb3IgYywxMDAsMTAwLDAuNVxuXHRcdFx0Y2lyY2xlIHgseSxAcmFkaXVzXG5cblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuXHRcdGhpdGxpc3QgPSBbXVxuXHRcdGZvciBbeCx5LGNdLGkgaW4gQGNpcmNsZXNcblx0XHRcdGlmIGRpc3QoeCx5LG14LG15KSA8IEByYWRpdXMgdGhlbiBoaXRsaXN0LnB1c2ggaVxuXHRcdGlmIGhpdGxpc3QubGVuZ3RoID09IDFcblx0XHRcdGkgPSBoaXRsaXN0WzBdXG5cdFx0XHRjaXJjbGUgPSBAY2lyY2xlc1tpXVxuXHRcdFx0aWYgQG1lbW9yeSA9PSAtMVxuXHRcdFx0XHRAbWVtb3J5ID0gY2lyY2xlWzJdXG5cdFx0XHRcdEBjaXJjbGVzLnNwbGljZSBpLDFcblx0XHRcdGVsc2UgaWYgXy5pc0VxdWFsKEBtZW1vcnksIGNpcmNsZVsyXSlcblx0XHRcdFx0QG1lbW9yeSA9IC0xXG5cdFx0XHRcdEBjaXJjbGVzLnNwbGljZSBpLDFcblx0XHRcdFx0aWYgQGNpcmNsZXMubGVuZ3RoID09IDBcblx0XHRcdFx0XHRAdXBkYXRlSGlnaFNjb3JlKCkgaWYgQG5hbWUgIT0gXCJcIlxuXHRcdFx0XHRcdEBjaGFuZ2VMZXZlbCAxXG5cdFx0XHRlbHNlXG5cdFx0XHRcdEBjaGFuZ2VMZXZlbCAtMVxuXHRcdGVsc2Vcblx0XHRcdEBjaGFuZ2VMZXZlbCAtMVxuXG5cdHVwZGF0ZUhpZ2hTY29yZSA6IC0+XG5cdFx0QGhpZ2hTY29yZVtAbmFtZV0gPSBfLm1heCBbQGxldmVsLCBAaGlnaFNjb3JlW0BuYW1lXV1cblx0XHRAdG9wTGlzdCA9IF8ucGFpcnMgQGhpZ2hTY29yZVxuXHRcdEB0b3BMaXN0ID0gXy5zb3J0QnkgQHRvcExpc3QsIChbbmFtZSxsZXZlbF0pIC0+IC1sZXZlbFxuXG5cdGNoYW5nZUxldmVsIDogKGQpIC0+XG5cdFx0QG1lbW9yeSA9IC0xXG5cdFx0QGxldmVsID0gY29uc3RyYWluIEBsZXZlbCtkLCAxLCAyMFxuXHRcdEBjaXJjbGVzID0gW11cblx0XHRAcmFkaXVzID0gNTBcblx0XHRmb3IgaSBpbiByYW5nZSBAbGV2ZWxcblx0XHRcdEByYWRpdXMgKj0gMC45NVxuXHRcdFx0YyA9IGludCBpICogMzYwIC8gQGxldmVsXG5cdFx0XHRAY2lyY2xlcy5wdXNoIFtAcmFuZGludCgyMDApLCBAcmFuZGludCgyMDApLCBjXVxuXHRcdFx0QGNpcmNsZXMucHVzaCBbQHJhbmRpbnQoMjAwKSwgQHJhbmRpbnQoMjAwKSwgY11cblxuXHRlbnRlck5hbWUgOiAtPiBAbmFtZSA9IEByZWFkVGV4dCgpXG5cbmFwcCA9IG5ldyBDb2xvclBhaXIgXCJhXCJcblwiXCJcIlxuXHRjOlxuXHRcdGFwcCA6IFwicmVzZXQoKXxlbnRlck5hbWUoKVwiXG5cdGU6XG5cdFx0Q29sb3JQYWlyIDogXCJodHRwczovL2NocmlzdGVybmlsc3Nvbi5naXRodWIuaW8vQ29sb3JQYWlyXCJcblxuSURfQ29tcGxleCA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCJcIlwiXG4jIExPQzo4MCBiZyBmYyBzYyByYW5nZSAjICogLyArICUlIFtdIGxpbmUgY2lyY2xlIHRleHQgdGV4dEFsaWduIHRleHRTaXplIGZvciBpbiBpZiB0aGVuIGVsc2UgcmV0dXJuIGludFxuIyAgICAgICAge30gZGlzdCBfLmlzRXF1YWwgYW5kIDwgIT0gPT0gcHVzaCBwb3AgbGVuZ3RoIGNvbnN0cmFpbiBjbGFzcyBleHRlbmRzIGNvbnN0cnVjdG9yIG5ldyBAIHN1cGVyIC0+XG5cbmNsYXNzIENvbXBsZXggZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0ZHJhdyA6IC0+XG5cdHJhbmRpbnQgOiAobikgLT4gaW50IG4gKiBmcmFjdGlvbiAxMDAwMCAqIE1hdGguc2luIEBzZWVkKytcblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuYXBwID0gbmV3IENvbXBsZXhcblwiXCJcIlxuXHRhOlwiXCJcIlxuY2xhc3MgQ29tcGxleCBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRcdEBSQURJVVMgPSAyNVxuXHRcdEBidXR0b25zID0gW1szMCwxMzAsJ20nXSxbNzAsMTcwLCcqaSddLFsxMzAsMTcwLCcqMiddLFsxNzAsMTMwLCcrMSddLFszMCwzMCwndW5kbyddLCBbMTcwLDMwLCduZXcnXV1cblx0XHRAc2VlZCA9IDBcblx0XHRAbGV2ZWwgPSAxXG5cdFx0QGNyZWF0ZUdhbWUoKVxuXHRyYW5kaW50IDogKG4pIC0+IGludCBuICogZnJhY3Rpb24gMTAwMDAgKiBNYXRoLnNpbiBAc2VlZCsrXG5cdGdyIDogLT5cblx0XHRzYyAxLDEsMSwwLjVcblx0XHRmb3IgaSBpbiByYW5nZSAyMVxuXHRcdFx0bGluZSAwLCAxMCAqIGksIDIwMCwgMTAgKiBpXG5cdFx0XHRsaW5lIDEwICogaSwgMCwgMTAgKiBpLCAyMDBcblx0XHRzYyAxLDEsMVxuXHRcdGxpbmUgMTAwLDAsIDEwMCwyMDBcblx0XHRsaW5lIDAsMTAwLCAyMDAsMTAwXG5cdGRyYXcgOiAtPlxuXHRcdEBidXR0b25zWzRdWzJdID0gQGxldmVsIC0gQGhpc3RvcnkubGVuZ3RoXG5cdFx0YmcgMFxuXHRcdEBncigpXG5cdFx0dGV4dEFsaWduIENFTlRFUixDRU5URVJcblx0XHR0ZXh0U2l6ZSAyNVxuXHRcdHNjKClcblx0XHRmYyAxLDAsMFxuXHRcdGNpcmNsZSAxMDArMTAqQGJbMF0sIDEwMC0xMCpAYlsxXSwgNVxuXHRcdGZjIDAsMSwwXG5cdFx0Y2lyY2xlIDEwMCsxMCpAYVswXSwgMTAwLTEwKkBhWzFdLCA0XG5cdFx0Zm9yIFt4LHksdHh0XSxpIGluIEBidXR0b25zXG5cdFx0XHRmYyAxLDEsMCwwLjRcblx0XHRcdGNpcmNsZSB4LHksQFJBRElVU1xuXHRcdFx0ZmMgMSwxLDBcblx0XHRcdHRleHQgdHh0LHgseVxuXHRuZXdHYW1lIDogLT5cblx0XHRpZiBAbGV2ZWwgPj0gQGhpc3RvcnkubGVuZ3RoIGFuZCBfLmlzRXF1YWwoQGEsQGIpIHRoZW4gZD0xIGVsc2UgZD0tMVxuXHRcdEBsZXZlbCA9IGNvbnN0cmFpbiBAbGV2ZWwrZCwxLDE2XG5cdFx0QGNyZWF0ZUdhbWUoKVxuXHRjcmVhdGVHYW1lIDogLT5cblx0XHRAaGlzdG9yeSA9IFtdXG5cdFx0QGEgPSBbLTEwICsgQHJhbmRpbnQoMjApLCAtMTAgKyBAcmFuZGludCgyMCldXG5cdFx0cTEgPSBbQGFdXG5cdFx0cTIgPSBbXVxuXHRcdHZpc2l0ZWQgPSB7fVxuXHRcdHZpc2l0ZWRbQGFdID0gdHJ1ZVxuXHRcdGV4cGFuZCA9IChuKSAtPlxuXHRcdFx0aWYgdmlzaXRlZFtuXSB0aGVuIHJldHVyblxuXHRcdFx0aWYgblswXSpuWzBdICsgblsxXSpuWzFdID4gMTAwMCB0aGVuIHJldHVyblxuXHRcdFx0dmlzaXRlZFtuXSA9IHRydWVcblx0XHRcdHEyLnB1c2ggblxuXHRcdGZvciBsZXZlbCBpbiByYW5nZSBAbGV2ZWxcblx0XHRcdGZvciBbeCx5XSBpbiBxMVxuXHRcdFx0XHRleHBhbmQgW3kseF1cblx0XHRcdFx0ZXhwYW5kIFsteSx4XVxuXHRcdFx0XHRleHBhbmQgWzIqeCwyKnldXG5cdFx0XHRcdGV4cGFuZCBbeCsxLHldXG5cdFx0XHRxMSA9IHEyXG5cdFx0XHRxMiA9IFtdXG5cdFx0QGIgPSBAc2VsZWN0VGFyZ2V0IHExXG5cdHNlbGVjdFRhcmdldCA6IChsc3QpIC0+ICMgd2l0aGluIDIxeDIxIHdpbmRvdywgaWYgcG9zc2libGVcblx0XHRicyA9IChbeCx5XSBmb3IgW3gseV0gaW4gbHN0IHdoZW4gLTEwIDw9IHggPD0gMTAgYW5kIC0xMCA8PSB5IDw9IDEwKVxuXHRcdHJldHVybiBic1tAcmFuZGludChicy5sZW5ndGgpXSBpZiBicy5sZW5ndGggPiAwXG5cdFx0Xy5taW4gbHN0LCAoW3gseV0pIC0+IGRpc3QgMCwwLHgseVxuXHR1bmRvIDogLT5cblx0XHRpZiBAaGlzdG9yeS5sZW5ndGggPT0gMCB0aGVuIHJldHVyblxuXHRcdEBhID0gQGhpc3RvcnkucG9wKClcblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPlxuXHRcdGluZGV4ID0gLTFcblx0XHRmb3IgW3gseSx0eHRdLGkgaW4gQGJ1dHRvbnNcblx0XHRcdGlmIGRpc3QobXgsbXkseCx5KSA8IEBSQURJVVMgdGhlbiBpbmRleCA9IGlcblx0XHRbeCx5XSA9IEBhXG5cdFx0YSA9IFtdXG5cdFx0aWYgaW5kZXggPT0gMCB0aGVuIGEgPSBbeSx4XVxuXHRcdGlmIGluZGV4ID09IDEgdGhlbiBhID0gWy15LHhdXG5cdFx0aWYgaW5kZXggPT0gMiB0aGVuIGEgPSBbMip4LDIqeV1cblx0XHRpZiBpbmRleCA9PSAzIHRoZW4gYSA9IFt4KzEseV1cblx0XHRpZiBpbmRleCA9PSA0IHRoZW4gQHVuZG8oKVxuXHRcdGlmIGluZGV4ID09IDUgdGhlbiBAbmV3R2FtZSgpXG5cdFx0aWYgYS5sZW5ndGggIT0gMFxuXHRcdFx0QGhpc3RvcnkucHVzaCBAYVxuXHRcdFx0QGEgPSBhXG5cbmFwcCA9IG5ldyBDb21wbGV4IFwiYVwiXG5cblwiXCJcIlxuXHRjOlxuXHRcdGFwcCA6IFwicmVzZXQoKVwiXG5cdGU6XG5cdFx0XCJLb21wbGV4YSB0YWxcIiA6IFwiaHR0cDovL3d3dy5tYXR0ZWJva2VuLnNlL2xla3Rpb25lci9tYXR0ZS00L2tvbXBsZXhhLXRhbC9yYWtuYS1tZWQta29tcGxleGEtdGFsXCJcblxuSURfQ29ubmVjdDQgPVxuXHR2OicyMDE3LTA0LTI5J1xuXHRiOlwiXCJcIlxuIyBMT0M6MzMgJSBiZyBmYyBzYyBzdyBjaXJjbGUgcmFuZ2UgIyB0ZXh0IHRleHRBbGlnbiB0ZXh0U2l6ZSBmb3IgaW5cbiMgICAgICAgIHB1c2ggcG9wIGNsYXNzIGV4dGVuZHMgY29uc3RydWN0b3IgbmV3IEAgc3VwZXIgLT5cblxuY2xhc3MgQ29ubmVjdDQgZXh0ZW5kcyBBcHBsaWNhdGlvblxuXHRyZXNldCA6IC0+XG5cdFx0c3VwZXJcblx0ZHJhdyAgOiAtPlxuXHR1bmRvICA6IC0+XG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT5cbmFwcCA9IG5ldyBDb25uZWN0NFxuXHRcdFx0XCJcIlwiXG5cdGE6XCJcIlwiXG5jbGFzcyBDb25uZWN0NCBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRcdEBTSVpFID0gMjdcblx0XHRAbGlzdCA9IChbXSBmb3IgaSBpbiByYW5nZSA3KVxuXHRcdEBtb3ZlcyA9IFtdXG5cdGRyYXcgOiAtPlxuXHRcdGJnIDBcblx0XHR0ZXh0QWxpZ24gQ0VOVEVSLENFTlRFUlxuXHRcdHRleHRTaXplIEBTSVpFLzJcblx0XHRmYygpXG5cdFx0c2MgMC4xLDAuMywxXG5cdFx0c3cgMC4yICogQFNJWkVcblx0XHRmb3IgaSBpbiByYW5nZSA3XG5cdFx0XHRmb3IgaiBpbiByYW5nZSA2XG5cdFx0XHRcdGNpcmNsZSAxMDAtQFNJWkUqMytAU0laRSppLCAxODAtQFNJWkUqaiwgQFNJWkUvMlxuXHRcdGZvciBjb2x1bW4saSBpbiBAbGlzdFxuXHRcdFx0Zm9yIG5yLGogaW4gY29sdW1uXG5cdFx0XHRcdGZjIDEsbnIlMiwwXG5cdFx0XHRcdHN3IDFcblx0XHRcdFx0Y2lyY2xlIDEwMC1AU0laRSozK0BTSVpFKmksIDE4MC1AU0laRSpqLCBAU0laRSowLjRcblx0XHRcdFx0ZmMgMFxuXHRcdFx0XHRzYygpXG5cdFx0XHRcdHRleHQgbnIsIDEwMC1AU0laRSozK0BTSVpFKmksIDE4MC1AU0laRSpqXG5cdFx0c2MoKVxuXHRcdGZjIDEsKEBtb3Zlcy5sZW5ndGgrMSklMiwwXG5cdFx0Y2lyY2xlIDEwMCwxNSwxMFxuXHRtb3VzZVByZXNzZWQgOiAobXgsbXkpIC0+XG5cdFx0bnIgPSBpbnQgKG14LSgyMDAtNypAU0laRSkvMikvQFNJWkVcblx0XHRpZiAwIDw9IG5yIDw9IDZcblx0XHRcdEBtb3Zlcy5wdXNoIG5yXG5cdFx0XHRAbGlzdFtucl0ucHVzaCBAbW92ZXMubGVuZ3RoXG5cdHVuZG8gOiAtPiBpZiBAbW92ZXMubGVuZ3RoID4gMCB0aGVuIEBsaXN0W0Btb3Zlcy5wb3AoKV0ucG9wKClcblxuYXBwID0gbmV3IENvbm5lY3Q0IFwiYVwiXG5cIlwiXCJcblx0Yzpcblx0XHRhcHAgOiBcInJlc2V0KCl8dW5kbygpXCJcblx0ZTpcblx0XHRXaWtpcGVkaWEgOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nvbm5lY3RfRm91clwiXG5cbklEX0Nvcm5lclBvaW50cyA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6IFwiXCJcIlxuIyBMT0M6OSBzYyBzdyAjIHBvaW50XG5cbnN3XG5zY1xucG9pbnRcblxuXCJcIlwiXG5cdGE6IFwiXCJcIlxuc3cgMTBcbnNjIDEsMCwwXG5wb2ludCAwLDBcbnNjIDAsMSwwXG5wb2ludCAyMDAsMFxuc2MgMSwxLDBcbnBvaW50IDAsMjAwXG5zYyAwXG5wb2ludCAyMDAsMjAwXG5cIlwiXCJcblx0ZSA6XG5cdFx0TWF0dGVib2tlbiA6IFwiaHR0cDovL3d3dy5tYXR0ZWJva2VuLnNlL2xla3Rpb25lci9tYXR0ZS0xL2Z1bmt0aW9uZXIva29vcmRpbmF0c3lzdGVtXCJcblxuSURfQ29ybmVyUG9pbnRzMyA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6IFwiIyBMT0M6MTcgc2Mgc3cgIyBwb2ludFxcblwiXG5cdGE6IFwiXCJcIlxuc3cgMTBcbnNjIDEsMCwwXG5wb2ludCAyMCwwXG5wb2ludCAyMCwyMFxucG9pbnQgMCwyMFxuXG5zYyAwLDEsMFxucG9pbnQgMTgwLDBcbnBvaW50IDE4MCwyMFxucG9pbnQgMjAwLDIwXG5cbnNjIDEsMSwwXG5wb2ludCAyMCwxODBcbnBvaW50IDIwLDIwMFxucG9pbnQgMCwxODBcblxuc2MgMVxucG9pbnQgMTgwLDE4MFxucG9pbnQgMTgwLDIwMFxucG9pbnQgMjAwLDE4MFxuXCJcIlwiXG5cdGUgOlxuXHRcdE1hdHRlYm9rZW4gOiBcImh0dHA6Ly93d3cubWF0dGVib2tlbi5zZS9sZWt0aW9uZXIvbWF0dGUtMS9mdW5rdGlvbmVyL2tvb3JkaW5hdHN5c3RlbVwiXG5cbklEX0Nvcm5lclBvaW50czcgPVxuXHR2OicyMDE3LTA0LTI5J1xuXHRiOiBcIiMgTE9DOjE3IHNjIHN3ICMgcG9pbnRcXG5cIlxuXHRhOiBcIlwiXCJcbnN3IDEwXG5zYyAxLDAsMFxucG9pbnQgMzAsMFxucG9pbnQgMzAsMTBcbnBvaW50IDMwLDIwXG5wb2ludCAzMCwzMFxucG9pbnQgMTAsMzBcbnBvaW50IDIwLDMwXG5wb2ludCAwLDMwXG5cbnNjIDAsMSwwXG5wb2ludCAxNzAsMjAwXG5wb2ludCAxNzAsMTkwXG5wb2ludCAxNzAsMTgwXG5wb2ludCAxNzAsMTcwXG5wb2ludCAxOTAsMTcwXG5wb2ludCAxODAsMTcwXG5wb2ludCAyMDAsMTcwXG5cIlwiXCJcblx0ZSA6XG5cdFx0TWF0dGVib2tlbiA6IFwiaHR0cDovL3d3dy5tYXR0ZWJva2VuLnNlL2xla3Rpb25lci9tYXR0ZS0xL2Z1bmt0aW9uZXIva29vcmRpbmF0c3lzdGVtXCJcblxuSURfQ291bnRlciA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCJcIlwiXG4jIExPQzoxMiBiZyBmYyBzYyAjIHRleHQgdGV4dEFsaWduIHRleHRTaXplICsgLSBjbGFzcyBleHRlbmRzIGNvbnN0cnVjdG9yIG5ldyBAIHN1cGVyIC0+XG4jIEtsaWNrYSBww6UgcmVzZXQoKSBvbSBkdSBmw6VyIGV0dCBmZWxtZWRkZWxhbmRlIVxuXG5jbGFzcyBDb3VudGVyIGV4dGVuZHMgQXBwbGljYXRpb25cblx0cmVzZXQgOiAtPlxuXHRcdHN1cGVyXG5cdGRyYXcgIDogLT5cblx0dXAgICAgOiAtPlxuXHRkb3duICA6IC0+XG5cdG1vdXNlUHJlc3NlZCA6IChteCxteSkgLT4gcHJpbnQgXCJtb3VzZVByZXNzZWRcIixteCxteVxuYXBwID0gbmV3IENvdW50ZXJcblwiXCJcIlxuXHRhOlwiXCJcIlxuY2xhc3MgQ291bnRlciBleHRlbmRzIEFwcGxpY2F0aW9uXG5cdHJlc2V0IDogLT5cblx0XHRzdXBlclxuXHRcdEBjb3VudGVyID0gMFxuXHR1cCA6IC0+IEBjb3VudGVyICs9IDFcblx0ZG93biA6IC0+IEBjb3VudGVyIC09IDFcblx0ZHJhdyA6IC0+XG5cdFx0YmcgMC41XG5cdFx0ZmMgMSwxLDBcblx0XHRzYygpXG5cdFx0dGV4dEFsaWduIENFTlRFUixDRU5URVJcblx0XHR0ZXh0U2l6ZSAxMDBcblx0XHR0ZXh0IEBjb3VudGVyLDEwMCwxMDBcblx0bW91c2VQcmVzc2VkIDogKG14LG15KSAtPiBpZiBteSA8IDEwMCB0aGVuIEBjb3VudGVyICs9IDEgZWxzZSBAY291bnRlciAtPSAxXG5cbmFwcCA9IG5ldyBDb3VudGVyIFwiYVwiXG5cIlwiXCJcblx0Yzpcblx0XHRhcHAgOiBcInJlc2V0KCl8dXAoKXxkb3duKClcIlxuXG5JRF9Dcm9zcyA9XG5cdHY6JzIwMTctMDQtMjknXG5cdGI6XCIjIExPQzo0IGZjICMgcmVjdFxcblwiXG5cdGE6XCJcIlwiXG5mYyAxLDAsMFxuc2MoKVxucmVjdCA4NSw3MCwgNzAsMTBcbnJlY3QgMTE1LDQwLCAxMCwxMDBcblwiXCJcIlxuXG4iXX0=
//# sourceURL=C:\github\p5Dojo\coffee\data\C.coffee